/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8
                <= self.storage.as_ref().len()
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CV_8SC3: i32 = 17;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const CV_HAL_ERROR_OK: u32 = 0;
pub const CV_HAL_ERROR_NOT_IMPLEMENTED: u32 = 1;
pub const CV_HAL_ERROR_UNKNOWN: i32 = -1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const CV_CN_MAX: u32 = 512;
pub const CV_CN_SHIFT: u32 = 3;
pub const CV_DEPTH_MAX: u32 = 8;
pub const CV_8U: u32 = 0;
pub const CV_8S: u32 = 1;
pub const CV_16U: u32 = 2;
pub const CV_16S: u32 = 3;
pub const CV_32S: u32 = 4;
pub const CV_32F: u32 = 5;
pub const CV_64F: u32 = 6;
pub const CV_USRTYPE1: u32 = 7;
pub const CV_MAT_DEPTH_MASK: u32 = 7;
pub const CV_HAL_CMP_EQ: u32 = 0;
pub const CV_HAL_CMP_GT: u32 = 1;
pub const CV_HAL_CMP_GE: u32 = 2;
pub const CV_HAL_CMP_LT: u32 = 3;
pub const CV_HAL_CMP_LE: u32 = 4;
pub const CV_HAL_CMP_NE: u32 = 5;
pub const CV_HAL_BORDER_CONSTANT: u32 = 0;
pub const CV_HAL_BORDER_REPLICATE: u32 = 1;
pub const CV_HAL_BORDER_REFLECT: u32 = 2;
pub const CV_HAL_BORDER_WRAP: u32 = 3;
pub const CV_HAL_BORDER_REFLECT_101: u32 = 4;
pub const CV_HAL_BORDER_TRANSPARENT: u32 = 5;
pub const CV_HAL_BORDER_ISOLATED: u32 = 16;
pub const CV_HAL_DFT_INVERSE: u32 = 1;
pub const CV_HAL_DFT_SCALE: u32 = 2;
pub const CV_HAL_DFT_ROWS: u32 = 4;
pub const CV_HAL_DFT_COMPLEX_OUTPUT: u32 = 16;
pub const CV_HAL_DFT_REAL_OUTPUT: u32 = 32;
pub const CV_HAL_DFT_TWO_STAGE: u32 = 64;
pub const CV_HAL_DFT_STAGE_COLS: u32 = 128;
pub const CV_HAL_DFT_IS_CONTINUOUS: u32 = 512;
pub const CV_HAL_DFT_IS_INPLACE: u32 = 1024;
pub const CV_HAL_SVD_NO_UV: u32 = 1;
pub const CV_HAL_SVD_SHORT_UV: u32 = 2;
pub const CV_HAL_SVD_MODIFY_A: u32 = 4;
pub const CV_HAL_SVD_FULL_UV: u32 = 8;
pub const CV_HAL_GEMM_1_T: u32 = 1;
pub const CV_HAL_GEMM_2_T: u32 = 2;
pub const CV_HAL_GEMM_3_T: u32 = 4;
pub const CV_ENABLE_UNROLLED: u32 = 1;
pub const CV_CPU_NONE: u32 = 0;
pub const CV_CPU_MMX: u32 = 1;
pub const CV_CPU_SSE: u32 = 2;
pub const CV_CPU_SSE2: u32 = 3;
pub const CV_CPU_SSE3: u32 = 4;
pub const CV_CPU_SSSE3: u32 = 5;
pub const CV_CPU_SSE4_1: u32 = 6;
pub const CV_CPU_SSE4_2: u32 = 7;
pub const CV_CPU_POPCNT: u32 = 8;
pub const CV_CPU_FP16: u32 = 9;
pub const CV_CPU_AVX: u32 = 10;
pub const CV_CPU_AVX2: u32 = 11;
pub const CV_CPU_FMA3: u32 = 12;
pub const CV_CPU_AVX_512F: u32 = 13;
pub const CV_CPU_AVX_512BW: u32 = 14;
pub const CV_CPU_AVX_512CD: u32 = 15;
pub const CV_CPU_AVX_512DQ: u32 = 16;
pub const CV_CPU_AVX_512ER: u32 = 17;
pub const CV_CPU_AVX_512IFMA512: u32 = 18;
pub const CV_CPU_AVX_512IFMA: u32 = 18;
pub const CV_CPU_AVX_512PF: u32 = 19;
pub const CV_CPU_AVX_512VBMI: u32 = 20;
pub const CV_CPU_AVX_512VL: u32 = 21;
pub const CV_CPU_NEON: u32 = 100;
pub const CV_CPU_VSX: u32 = 200;
pub const CV_CPU_AVX512_SKX: u32 = 256;
pub const CV_HARDWARE_MAX_FEATURE: u32 = 512;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const CV_MMX: u32 = 1;
pub const CV_SSE: u32 = 1;
pub const CV_SSE2: u32 = 1;
pub const CV_SSE3: u32 = 0;
pub const CV_SSSE3: u32 = 0;
pub const CV_SSE4_1: u32 = 0;
pub const CV_SSE4_2: u32 = 0;
pub const CV_POPCNT: u32 = 0;
pub const CV_AVX: u32 = 0;
pub const CV_FP16: u32 = 0;
pub const CV_AVX2: u32 = 0;
pub const CV_FMA3: u32 = 0;
pub const CV_AVX_512F: u32 = 0;
pub const CV_AVX_512BW: u32 = 0;
pub const CV_AVX_512CD: u32 = 0;
pub const CV_AVX_512DQ: u32 = 0;
pub const CV_AVX_512ER: u32 = 0;
pub const CV_AVX_512IFMA512: u32 = 0;
pub const CV_AVX_512PF: u32 = 0;
pub const CV_AVX_512VBMI: u32 = 0;
pub const CV_AVX_512VL: u32 = 0;
pub const CV_AVX512_SKX: u32 = 0;
pub const CV_NEON: u32 = 0;
pub const CV_VSX: u32 = 0;
pub const CV_PI: f64 = 3.141592653589793;
pub const CV_2PI: f64 = 6.283185307179586;
pub const CV_LOG2: f64 = 0.6931471805599453;
pub const CV_FP16_TYPE: u32 = 0;
pub const OPENCV_ABI_COMPATIBILITY: u32 = 300;
pub const CV_MAT_CN_MASK: u32 = 4088;
pub const CV_MAT_TYPE_MASK: u32 = 4095;
pub const CV_MAT_CONT_FLAG_SHIFT: u32 = 14;
pub const CV_MAT_CONT_FLAG: u32 = 16384;
pub const CV_SUBMAT_FLAG_SHIFT: u32 = 15;
pub const CV_SUBMAT_FLAG: u32 = 32768;
pub const _ASSERT_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const CV_RNG_COEFF: u32 = 4164903690;
pub const IPL_DEPTH_SIGN: u32 = 2147483648;
pub const IPL_DEPTH_1U: u32 = 1;
pub const IPL_DEPTH_8U: u32 = 8;
pub const IPL_DEPTH_16U: u32 = 16;
pub const IPL_DEPTH_32F: u32 = 32;
pub const IPL_DEPTH_8S: u32 = 2147483656;
pub const IPL_DEPTH_16S: u32 = 2147483664;
pub const IPL_DEPTH_32S: u32 = 2147483680;
pub const IPL_DATA_ORDER_PIXEL: u32 = 0;
pub const IPL_DATA_ORDER_PLANE: u32 = 1;
pub const IPL_ORIGIN_TL: u32 = 0;
pub const IPL_ORIGIN_BL: u32 = 1;
pub const IPL_ALIGN_4BYTES: u32 = 4;
pub const IPL_ALIGN_8BYTES: u32 = 8;
pub const IPL_ALIGN_16BYTES: u32 = 16;
pub const IPL_ALIGN_32BYTES: u32 = 32;
pub const IPL_ALIGN_DWORD: u32 = 4;
pub const IPL_ALIGN_QWORD: u32 = 8;
pub const IPL_BORDER_CONSTANT: u32 = 0;
pub const IPL_BORDER_REPLICATE: u32 = 1;
pub const IPL_BORDER_REFLECT: u32 = 2;
pub const IPL_BORDER_WRAP: u32 = 3;
pub const IPL_IMAGE_HEADER: u32 = 1;
pub const IPL_IMAGE_DATA: u32 = 2;
pub const IPL_IMAGE_ROI: u32 = 4;
pub const IPL_BORDER_REFLECT_101: u32 = 4;
pub const IPL_BORDER_TRANSPARENT: u32 = 5;
pub const CV_TYPE_NAME_IMAGE: &'static [u8; 13usize] = b"opencv-image\0";
pub const IPL_DEPTH_64F: u32 = 64;
pub const CV_AUTO_STEP: u32 = 2147483647;
pub const CV_MAGIC_MASK: u32 = 4294901760;
pub const CV_MAT_MAGIC_VAL: u32 = 1111621632;
pub const CV_TYPE_NAME_MAT: &'static [u8; 14usize] = b"opencv-matrix\0";
pub const CV_MATND_MAGIC_VAL: u32 = 1111687168;
pub const CV_TYPE_NAME_MATND: &'static [u8; 17usize] = b"opencv-nd-matrix\0";
pub const CV_MAX_DIM: u32 = 32;
pub const CV_MAX_DIM_HEAP: u32 = 1024;
pub const CV_SPARSE_MAT_MAGIC_VAL: u32 = 1111752704;
pub const CV_TYPE_NAME_SPARSE_MAT: &'static [u8; 21usize] =
    b"opencv-sparse-matrix\0";
pub const CV_HIST_MAGIC_VAL: u32 = 1111818240;
pub const CV_HIST_UNIFORM_FLAG: u32 = 1024;
pub const CV_HIST_RANGES_FLAG: u32 = 2048;
pub const CV_HIST_ARRAY: u32 = 0;
pub const CV_HIST_SPARSE: u32 = 1;
pub const CV_HIST_TREE: u32 = 1;
pub const CV_HIST_UNIFORM: u32 = 1;
pub const CV_TERMCRIT_ITER: u32 = 1;
pub const CV_TERMCRIT_NUMBER: u32 = 1;
pub const CV_TERMCRIT_EPS: u32 = 2;
pub const CV_WHOLE_SEQ_END_INDEX: u32 = 1073741823;
pub const CV_STORAGE_MAGIC_VAL: u32 = 1116274688;
pub const CV_TYPE_NAME_SEQ: &'static [u8; 16usize] = b"opencv-sequence\0";
pub const CV_TYPE_NAME_SEQ_TREE: &'static [u8; 21usize] =
    b"opencv-sequence-tree\0";
pub const CV_SET_ELEM_IDX_MASK: u32 = 67108863;
pub const CV_TYPE_NAME_GRAPH: &'static [u8; 13usize] = b"opencv-graph\0";
pub const CV_SEQ_MAGIC_VAL: u32 = 1117323264;
pub const CV_SET_MAGIC_VAL: u32 = 1117257728;
pub const CV_SEQ_ELTYPE_BITS: u32 = 12;
pub const CV_SEQ_ELTYPE_MASK: u32 = 4095;
pub const CV_SEQ_ELTYPE_GENERIC: u32 = 0;
pub const CV_SEQ_ELTYPE_PTR: u32 = 7;
pub const CV_SEQ_ELTYPE_PPOINT: u32 = 7;
pub const CV_SEQ_ELTYPE_GRAPH_EDGE: u32 = 0;
pub const CV_SEQ_ELTYPE_GRAPH_VERTEX: u32 = 0;
pub const CV_SEQ_ELTYPE_TRIAN_ATR: u32 = 0;
pub const CV_SEQ_ELTYPE_CONNECTED_COMP: u32 = 0;
pub const CV_SEQ_KIND_BITS: u32 = 2;
pub const CV_SEQ_KIND_MASK: u32 = 12288;
pub const CV_SEQ_KIND_GENERIC: u32 = 0;
pub const CV_SEQ_KIND_CURVE: u32 = 4096;
pub const CV_SEQ_KIND_BIN_TREE: u32 = 8192;
pub const CV_SEQ_KIND_GRAPH: u32 = 4096;
pub const CV_SEQ_KIND_SUBDIV2D: u32 = 8192;
pub const CV_SEQ_FLAG_SHIFT: u32 = 14;
pub const CV_SEQ_FLAG_CLOSED: u32 = 16384;
pub const CV_SEQ_FLAG_SIMPLE: u32 = 0;
pub const CV_SEQ_FLAG_CONVEX: u32 = 0;
pub const CV_SEQ_FLAG_HOLE: u32 = 32768;
pub const CV_GRAPH_FLAG_ORIENTED: u32 = 16384;
pub const CV_GRAPH: u32 = 4096;
pub const CV_ORIENTED_GRAPH: u32 = 20480;
pub const CV_SEQ_POLYGON_TREE: u32 = 8192;
pub const CV_SEQ_CONNECTED_COMP: u32 = 0;
pub const CV_STORAGE_READ: u32 = 0;
pub const CV_STORAGE_WRITE: u32 = 1;
pub const CV_STORAGE_WRITE_TEXT: u32 = 1;
pub const CV_STORAGE_WRITE_BINARY: u32 = 1;
pub const CV_STORAGE_APPEND: u32 = 2;
pub const CV_STORAGE_MEMORY: u32 = 4;
pub const CV_STORAGE_FORMAT_MASK: u32 = 56;
pub const CV_STORAGE_FORMAT_AUTO: u32 = 0;
pub const CV_STORAGE_FORMAT_XML: u32 = 8;
pub const CV_STORAGE_FORMAT_YAML: u32 = 16;
pub const CV_STORAGE_FORMAT_JSON: u32 = 24;
pub const CV_STORAGE_BASE64: u32 = 64;
pub const CV_STORAGE_WRITE_BASE64: u32 = 65;
pub const CV_NODE_NONE: u32 = 0;
pub const CV_NODE_INT: u32 = 1;
pub const CV_NODE_INTEGER: u32 = 1;
pub const CV_NODE_REAL: u32 = 2;
pub const CV_NODE_FLOAT: u32 = 2;
pub const CV_NODE_STR: u32 = 3;
pub const CV_NODE_STRING: u32 = 3;
pub const CV_NODE_REF: u32 = 4;
pub const CV_NODE_SEQ: u32 = 5;
pub const CV_NODE_MAP: u32 = 6;
pub const CV_NODE_TYPE_MASK: u32 = 7;
pub const CV_NODE_FLOW: u32 = 8;
pub const CV_NODE_USER: u32 = 16;
pub const CV_NODE_EMPTY: u32 = 32;
pub const CV_NODE_NAMED: u32 = 64;
pub const CV_NODE_SEQ_SIMPLE: u32 = 256;
pub const CV_AUTOSTEP: u32 = 2147483647;
pub const CV_MAX_ARR: u32 = 10;
pub const CV_NO_DEPTH_CHECK: u32 = 1;
pub const CV_NO_CN_CHECK: u32 = 2;
pub const CV_NO_SIZE_CHECK: u32 = 4;
pub const CV_CMP_EQ: u32 = 0;
pub const CV_CMP_GT: u32 = 1;
pub const CV_CMP_GE: u32 = 2;
pub const CV_CMP_LT: u32 = 3;
pub const CV_CMP_LE: u32 = 4;
pub const CV_CMP_NE: u32 = 5;
pub const CV_CHECK_RANGE: u32 = 1;
pub const CV_CHECK_QUIET: u32 = 2;
pub const CV_RAND_UNI: u32 = 0;
pub const CV_RAND_NORMAL: u32 = 1;
pub const CV_SORT_EVERY_ROW: u32 = 0;
pub const CV_SORT_EVERY_COLUMN: u32 = 1;
pub const CV_SORT_ASCENDING: u32 = 0;
pub const CV_SORT_DESCENDING: u32 = 16;
pub const CV_GEMM_A_T: u32 = 1;
pub const CV_GEMM_B_T: u32 = 2;
pub const CV_GEMM_C_T: u32 = 4;
pub const CV_SVD_MODIFY_A: u32 = 1;
pub const CV_SVD_U_T: u32 = 2;
pub const CV_SVD_V_T: u32 = 4;
pub const CV_LU: u32 = 0;
pub const CV_SVD: u32 = 1;
pub const CV_SVD_SYM: u32 = 2;
pub const CV_CHOLESKY: u32 = 3;
pub const CV_QR: u32 = 4;
pub const CV_NORMAL: u32 = 16;
pub const CV_COVAR_SCRAMBLED: u32 = 0;
pub const CV_COVAR_NORMAL: u32 = 1;
pub const CV_COVAR_USE_AVG: u32 = 2;
pub const CV_COVAR_SCALE: u32 = 4;
pub const CV_COVAR_ROWS: u32 = 8;
pub const CV_COVAR_COLS: u32 = 16;
pub const CV_PCA_DATA_AS_ROW: u32 = 0;
pub const CV_PCA_DATA_AS_COL: u32 = 1;
pub const CV_PCA_USE_AVG: u32 = 2;
pub const CV_C: u32 = 1;
pub const CV_L1: u32 = 2;
pub const CV_L2: u32 = 4;
pub const CV_NORM_MASK: u32 = 7;
pub const CV_RELATIVE: u32 = 8;
pub const CV_DIFF: u32 = 16;
pub const CV_MINMAX: u32 = 32;
pub const CV_DIFF_C: u32 = 17;
pub const CV_DIFF_L1: u32 = 18;
pub const CV_DIFF_L2: u32 = 20;
pub const CV_RELATIVE_C: u32 = 9;
pub const CV_RELATIVE_L1: u32 = 10;
pub const CV_RELATIVE_L2: u32 = 12;
pub const CV_REDUCE_SUM: u32 = 0;
pub const CV_REDUCE_AVG: u32 = 1;
pub const CV_REDUCE_MAX: u32 = 2;
pub const CV_REDUCE_MIN: u32 = 3;
pub const CV_DXT_FORWARD: u32 = 0;
pub const CV_DXT_INVERSE: u32 = 1;
pub const CV_DXT_SCALE: u32 = 2;
pub const CV_DXT_INV_SCALE: u32 = 3;
pub const CV_DXT_INVERSE_SCALE: u32 = 3;
pub const CV_DXT_ROWS: u32 = 4;
pub const CV_DXT_MUL_CONJ: u32 = 8;
pub const CV_FRONT: u32 = 1;
pub const CV_BACK: u32 = 0;
pub const CV_GRAPH_VERTEX: u32 = 1;
pub const CV_GRAPH_TREE_EDGE: u32 = 2;
pub const CV_GRAPH_BACK_EDGE: u32 = 4;
pub const CV_GRAPH_FORWARD_EDGE: u32 = 8;
pub const CV_GRAPH_CROSS_EDGE: u32 = 16;
pub const CV_GRAPH_ANY_EDGE: u32 = 30;
pub const CV_GRAPH_NEW_TREE: u32 = 32;
pub const CV_GRAPH_BACKTRACKING: u32 = 64;
pub const CV_GRAPH_OVER: i32 = -1;
pub const CV_GRAPH_ALL_ITEMS: i32 = -1;
pub const CV_GRAPH_ITEM_VISITED_FLAG: u32 = 1073741824;
pub const CV_GRAPH_SEARCH_TREE_NODE_FLAG: u32 = 536870912;
pub const CV_GRAPH_FORWARD_EDGE_FLAG: u32 = 268435456;
pub const CV_KMEANS_USE_INITIAL_LABELS: u32 = 1;
pub const CV_ErrModeLeaf: u32 = 0;
pub const CV_ErrModeParent: u32 = 1;
pub const CV_ErrModeSilent: u32 = 2;
pub const CV_FILLED: i32 = -1;
pub const CV_AA: u32 = 16;
pub const CV_FONT_HERSHEY_SIMPLEX: u32 = 0;
pub const CV_FONT_HERSHEY_PLAIN: u32 = 1;
pub const CV_FONT_HERSHEY_DUPLEX: u32 = 2;
pub const CV_FONT_HERSHEY_COMPLEX: u32 = 3;
pub const CV_FONT_HERSHEY_TRIPLEX: u32 = 4;
pub const CV_FONT_HERSHEY_COMPLEX_SMALL: u32 = 5;
pub const CV_FONT_HERSHEY_SCRIPT_SIMPLEX: u32 = 6;
pub const CV_FONT_HERSHEY_SCRIPT_COMPLEX: u32 = 7;
pub const CV_FONT_ITALIC: u32 = 16;
pub const CV_FONT_VECTOR0: u32 = 0;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type uint = u32;
pub type schar = ::std::os::raw::c_schar;
pub type uchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type int64 = i64;
pub type uint64 = u64;
pub const CpuFeatures_CPU_MMX: CpuFeatures = 1;
pub const CpuFeatures_CPU_SSE: CpuFeatures = 2;
pub const CpuFeatures_CPU_SSE2: CpuFeatures = 3;
pub const CpuFeatures_CPU_SSE3: CpuFeatures = 4;
pub const CpuFeatures_CPU_SSSE3: CpuFeatures = 5;
pub const CpuFeatures_CPU_SSE4_1: CpuFeatures = 6;
pub const CpuFeatures_CPU_SSE4_2: CpuFeatures = 7;
pub const CpuFeatures_CPU_POPCNT: CpuFeatures = 8;
pub const CpuFeatures_CPU_FP16: CpuFeatures = 9;
pub const CpuFeatures_CPU_AVX: CpuFeatures = 10;
pub const CpuFeatures_CPU_AVX2: CpuFeatures = 11;
pub const CpuFeatures_CPU_FMA3: CpuFeatures = 12;
pub const CpuFeatures_CPU_AVX_512F: CpuFeatures = 13;
pub const CpuFeatures_CPU_AVX_512BW: CpuFeatures = 14;
pub const CpuFeatures_CPU_AVX_512CD: CpuFeatures = 15;
pub const CpuFeatures_CPU_AVX_512DQ: CpuFeatures = 16;
pub const CpuFeatures_CPU_AVX_512ER: CpuFeatures = 17;
pub const CpuFeatures_CPU_AVX_512IFMA512: CpuFeatures = 18;
pub const CpuFeatures_CPU_AVX_512IFMA: CpuFeatures = 18;
pub const CpuFeatures_CPU_AVX_512PF: CpuFeatures = 19;
pub const CpuFeatures_CPU_AVX_512VBMI: CpuFeatures = 20;
pub const CpuFeatures_CPU_AVX_512VL: CpuFeatures = 21;
pub const CpuFeatures_CPU_NEON: CpuFeatures = 100;
pub const CpuFeatures_CPU_VSX: CpuFeatures = 200;
pub const CpuFeatures_CPU_AVX512_SKX: CpuFeatures = 256;
pub const CpuFeatures_CPU_MAX_FEATURE: CpuFeatures = 512;
pub type CpuFeatures = u32;
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1
                as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_internal_list>())).__prev
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_internal_list>())).__next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __low as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 > ( ) ) ) . __high as * const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>()))
                .__g1_start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>()))
                .__g1_start32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(
        __statebuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).rand_type as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).rand_deg as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).rand_sep as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(
        __buf: *mut random_data,
        __result: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(
        __xsubi: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(
        __xsubi: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(
        __seed16v: *mut ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __func: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(
        __string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(
        __name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(
        __template: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(
        __template: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(
        __template: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(
        __command: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(
        __numer: ::std::os::raw::c_int,
        __denom: ::std::os::raw::c_int,
    ) -> div_t;
}
extern "C" {
    pub fn ldiv(
        __numer: ::std::os::raw::c_long,
        __denom: ::std::os::raw::c_long,
    ) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(
        __s: *mut ::std::os::raw::c_char,
        __wchar: wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: usize,
    ) -> usize;
}
extern "C" {
    pub fn rpmatch(
        __response: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(
        __loadavg: *mut f64,
        __nelem: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv16suf {
    pub i: ::std::os::raw::c_short,
    pub fmt: Cv16suf__fp16Format,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cv16suf__fp16Format {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_padding_0: u16,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_Cv16suf__fp16Format() {
    assert_eq!(
        ::std::mem::size_of::<Cv16suf__fp16Format>(),
        4usize,
        concat!("Size of: ", stringify!(Cv16suf__fp16Format))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv16suf__fp16Format>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv16suf__fp16Format))
    );
}
impl Cv16suf__fp16Format {
    #[inline]
    pub fn significand(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32)
        }
    }
    #[inline]
    pub fn set_significand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn exponent(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u32)
        }
    }
    #[inline]
    pub fn set_exponent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        significand: ::std::os::raw::c_uint,
        exponent: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<
            [u8; 2usize],
            u16,
        > = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let significand: u32 =
                unsafe { ::std::mem::transmute(significand) };
            significand as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let exponent: u32 = unsafe { ::std::mem::transmute(exponent) };
            exponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_Cv16suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv16suf>(),
        4usize,
        concat!("Size of: ", stringify!(Cv16suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv16suf>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv16suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv16suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv16suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv16suf>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv16suf),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv32suf {
    pub i: ::std::os::raw::c_int,
    pub u: ::std::os::raw::c_uint,
    pub f: f32,
    pub fmt: Cv32suf__fp32Format,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cv32suf__fp32Format {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_Cv32suf__fp32Format() {
    assert_eq!(
        ::std::mem::size_of::<Cv32suf__fp32Format>(),
        4usize,
        concat!("Size of: ", stringify!(Cv32suf__fp32Format))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv32suf__fp32Format>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv32suf__fp32Format))
    );
}
impl Cv32suf__fp32Format {
    #[inline]
    pub fn significand(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32)
        }
    }
    #[inline]
    pub fn set_significand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn exponent(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32)
        }
    }
    #[inline]
    pub fn set_exponent(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32)
        }
    }
    #[inline]
    pub fn set_sign(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        significand: ::std::os::raw::c_uint,
        exponent: ::std::os::raw::c_uint,
        sign: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<
            [u8; 4usize],
            u32,
        > = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let significand: u32 =
                unsafe { ::std::mem::transmute(significand) };
            significand as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let exponent: u32 = unsafe { ::std::mem::transmute(exponent) };
            exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_Cv32suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv32suf>(),
        4usize,
        concat!("Size of: ", stringify!(Cv32suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv32suf>(),
        4usize,
        concat!("Alignment of ", stringify!(Cv32suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv32suf>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv32suf),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Cv64suf {
    pub i: int64,
    pub u: uint64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Cv64suf() {
    assert_eq!(
        ::std::mem::size_of::<Cv64suf>(),
        8usize,
        concat!("Size of: ", stringify!(Cv64suf))
    );
    assert_eq!(
        ::std::mem::align_of::<Cv64suf>(),
        8usize,
        concat!("Alignment of ", stringify!(Cv64suf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Cv64suf>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cv64suf),
            "::",
            stringify!(f)
        )
    );
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__locale_struct>())).__names as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(
        __s: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(
        __s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(
        __string: *const ::std::os::raw::c_char,
        __maxlen: usize,
    ) -> usize;
}
extern "C" {
    pub fn strerror(
        __errnum: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(
        __s: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(
        __sig: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type CvArr = ::std::os::raw::c_void;
pub type CVStatus = ::std::os::raw::c_int;
pub const CV_StsOk: _bindgen_ty_1 = 0;
pub const CV_StsBackTrace: _bindgen_ty_1 = -1;
pub const CV_StsError: _bindgen_ty_1 = -2;
pub const CV_StsInternal: _bindgen_ty_1 = -3;
pub const CV_StsNoMem: _bindgen_ty_1 = -4;
pub const CV_StsBadArg: _bindgen_ty_1 = -5;
pub const CV_StsBadFunc: _bindgen_ty_1 = -6;
pub const CV_StsNoConv: _bindgen_ty_1 = -7;
pub const CV_StsAutoTrace: _bindgen_ty_1 = -8;
pub const CV_HeaderIsNull: _bindgen_ty_1 = -9;
pub const CV_BadImageSize: _bindgen_ty_1 = -10;
pub const CV_BadOffset: _bindgen_ty_1 = -11;
pub const CV_BadDataPtr: _bindgen_ty_1 = -12;
pub const CV_BadStep: _bindgen_ty_1 = -13;
pub const CV_BadModelOrChSeq: _bindgen_ty_1 = -14;
pub const CV_BadNumChannels: _bindgen_ty_1 = -15;
pub const CV_BadNumChannel1U: _bindgen_ty_1 = -16;
pub const CV_BadDepth: _bindgen_ty_1 = -17;
pub const CV_BadAlphaChannel: _bindgen_ty_1 = -18;
pub const CV_BadOrder: _bindgen_ty_1 = -19;
pub const CV_BadOrigin: _bindgen_ty_1 = -20;
pub const CV_BadAlign: _bindgen_ty_1 = -21;
pub const CV_BadCallBack: _bindgen_ty_1 = -22;
pub const CV_BadTileSize: _bindgen_ty_1 = -23;
pub const CV_BadCOI: _bindgen_ty_1 = -24;
pub const CV_BadROISize: _bindgen_ty_1 = -25;
pub const CV_MaskIsTiled: _bindgen_ty_1 = -26;
pub const CV_StsNullPtr: _bindgen_ty_1 = -27;
pub const CV_StsVecLengthErr: _bindgen_ty_1 = -28;
pub const CV_StsFilterStructContentErr: _bindgen_ty_1 = -29;
pub const CV_StsKernelStructContentErr: _bindgen_ty_1 = -30;
pub const CV_StsFilterOffsetErr: _bindgen_ty_1 = -31;
pub const CV_StsBadSize: _bindgen_ty_1 = -201;
pub const CV_StsDivByZero: _bindgen_ty_1 = -202;
pub const CV_StsInplaceNotSupported: _bindgen_ty_1 = -203;
pub const CV_StsObjectNotFound: _bindgen_ty_1 = -204;
pub const CV_StsUnmatchedFormats: _bindgen_ty_1 = -205;
pub const CV_StsBadFlag: _bindgen_ty_1 = -206;
pub const CV_StsBadPoint: _bindgen_ty_1 = -207;
pub const CV_StsBadMask: _bindgen_ty_1 = -208;
pub const CV_StsUnmatchedSizes: _bindgen_ty_1 = -209;
pub const CV_StsUnsupportedFormat: _bindgen_ty_1 = -210;
pub const CV_StsOutOfRange: _bindgen_ty_1 = -211;
pub const CV_StsParseError: _bindgen_ty_1 = -212;
pub const CV_StsNotImplemented: _bindgen_ty_1 = -213;
pub const CV_StsBadMemBlock: _bindgen_ty_1 = -214;
pub const CV_StsAssert: _bindgen_ty_1 = -215;
pub const CV_GpuNotSupported: _bindgen_ty_1 = -216;
pub const CV_GpuApiCallError: _bindgen_ty_1 = -217;
pub const CV_OpenGlNotSupported: _bindgen_ty_1 = -218;
pub const CV_OpenGlApiCallError: _bindgen_ty_1 = -219;
pub const CV_OpenCLApiCallError: _bindgen_ty_1 = -220;
pub const CV_OpenCLDoubleNotSupported: _bindgen_ty_1 = -221;
pub const CV_OpenCLInitError: _bindgen_ty_1 = -222;
pub const CV_OpenCLNoAMDBlasFft: _bindgen_ty_1 = -223;
pub type _bindgen_ty_1 = i32;
pub type CvRNG = uint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplImage {
    pub nSize: ::std::os::raw::c_int,
    pub ID: ::std::os::raw::c_int,
    pub nChannels: ::std::os::raw::c_int,
    pub alphaChannel: ::std::os::raw::c_int,
    pub depth: ::std::os::raw::c_int,
    pub colorModel: [::std::os::raw::c_char; 4usize],
    pub channelSeq: [::std::os::raw::c_char; 4usize],
    pub dataOrder: ::std::os::raw::c_int,
    pub origin: ::std::os::raw::c_int,
    pub align: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub roi: *mut _IplROI,
    pub maskROI: *mut _IplImage,
    pub imageId: *mut ::std::os::raw::c_void,
    pub tileInfo: *mut _IplTileInfo,
    pub imageSize: ::std::os::raw::c_int,
    pub imageData: *mut ::std::os::raw::c_char,
    pub widthStep: ::std::os::raw::c_int,
    pub BorderMode: [::std::os::raw::c_int; 4usize],
    pub BorderConst: [::std::os::raw::c_int; 4usize],
    pub imageDataOrigin: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__IplImage() {
    assert_eq!(
        ::std::mem::size_of::<_IplImage>(),
        144usize,
        concat!("Size of: ", stringify!(_IplImage))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplImage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).nSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(nSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).ID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(ID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).nChannels as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(nChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).alphaChannel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(alphaChannel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).colorModel as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(colorModel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).channelSeq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(channelSeq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).dataOrder as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(dataOrder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).origin as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).align as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).width as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).height as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).roi as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(roi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).maskROI as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(maskROI)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).imageId as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).tileInfo as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(tileInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).imageSize as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).imageData as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).widthStep as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(widthStep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).BorderMode as *const _
                as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(BorderMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).BorderConst as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(BorderConst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplImage>())).imageDataOrigin as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplImage),
            "::",
            stringify!(imageDataOrigin)
        )
    );
}
pub type IplImage = _IplImage;
pub type IplTileInfo = _IplTileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplROI {
    pub coi: ::std::os::raw::c_int,
    pub xOffset: ::std::os::raw::c_int,
    pub yOffset: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IplROI() {
    assert_eq!(
        ::std::mem::size_of::<_IplROI>(),
        20usize,
        concat!("Size of: ", stringify!(_IplROI))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplROI>(),
        4usize,
        concat!("Alignment of ", stringify!(_IplROI))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IplROI>())).coi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(coi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplROI>())).xOffset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(xOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplROI>())).yOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(yOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplROI>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplROI>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplROI),
            "::",
            stringify!(height)
        )
    );
}
pub type IplROI = _IplROI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplConvKernel {
    pub nCols: ::std::os::raw::c_int,
    pub nRows: ::std::os::raw::c_int,
    pub anchorX: ::std::os::raw::c_int,
    pub anchorY: ::std::os::raw::c_int,
    pub values: *mut ::std::os::raw::c_int,
    pub nShiftR: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IplConvKernel() {
    assert_eq!(
        ::std::mem::size_of::<_IplConvKernel>(),
        32usize,
        concat!("Size of: ", stringify!(_IplConvKernel))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplConvKernel>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplConvKernel))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).nCols as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).nRows as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).anchorX as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(anchorX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).anchorY as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(anchorY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).values as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernel>())).nShiftR as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernel),
            "::",
            stringify!(nShiftR)
        )
    );
}
pub type IplConvKernel = _IplConvKernel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplConvKernelFP {
    pub nCols: ::std::os::raw::c_int,
    pub nRows: ::std::os::raw::c_int,
    pub anchorX: ::std::os::raw::c_int,
    pub anchorY: ::std::os::raw::c_int,
    pub values: *mut f32,
}
#[test]
fn bindgen_test_layout__IplConvKernelFP() {
    assert_eq!(
        ::std::mem::size_of::<_IplConvKernelFP>(),
        24usize,
        concat!("Size of: ", stringify!(_IplConvKernelFP))
    );
    assert_eq!(
        ::std::mem::align_of::<_IplConvKernelFP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IplConvKernelFP))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernelFP>())).nCols as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(nCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernelFP>())).nRows as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(nRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernelFP>())).anchorX as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(anchorX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernelFP>())).anchorY as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(anchorY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IplConvKernelFP>())).values as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IplConvKernelFP),
            "::",
            stringify!(values)
        )
    );
}
pub type IplConvKernelFP = _IplConvKernelFP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvMat {
    pub type_: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub data: CvMat__bindgen_ty_1,
    pub rows: ::std::os::raw::c_int,
    pub cols: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvMat__bindgen_ty_1 {
    pub ptr: *mut uchar,
    pub s: *mut ::std::os::raw::c_short,
    pub i: *mut ::std::os::raw::c_int,
    pub fl: *mut f32,
    pub db: *mut f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CvMat__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvMat__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CvMat__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMat__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMat__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).ptr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).s as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).i as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).fl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat__bindgen_ty_1>())).db as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat__bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
}
#[test]
fn bindgen_test_layout_CvMat() {
    assert_eq!(
        ::std::mem::size_of::<CvMat>(),
        40usize,
        concat!("Size of: ", stringify!(CvMat))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMat>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat>())).refcount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMat>())).hdr_refcount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).rows as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMat>())).cols as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMat),
            "::",
            stringify!(cols)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvMatND {
    pub type_: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub data: CvMatND__bindgen_ty_1,
    pub dim: [CvMatND__bindgen_ty_2; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvMatND__bindgen_ty_1 {
    pub ptr: *mut uchar,
    pub fl: *mut f32,
    pub db: *mut f64,
    pub i: *mut ::std::os::raw::c_int,
    pub s: *mut ::std::os::raw::c_short,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CvMatND__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CvMatND__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMatND__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).ptr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).fl as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(fl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).db as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).i as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_1>())).s as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMatND__bindgen_ty_2 {
    pub size: ::std::os::raw::c_int,
    pub step: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMatND__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(CvMatND__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(CvMatND__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_2>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND__bindgen_ty_2>())).step as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND__bindgen_ty_2),
            "::",
            stringify!(step)
        )
    );
}
#[test]
fn bindgen_test_layout_CvMatND() {
    assert_eq!(
        ::std::mem::size_of::<CvMatND>(),
        288usize,
        concat!("Size of: ", stringify!(CvMatND))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMatND>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMatND))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND>())).dims as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND>())).refcount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND>())).hdr_refcount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMatND>())).data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvMatND>())).dim as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMatND),
            "::",
            stringify!(dim)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseMat {
    pub type_: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub refcount: *mut ::std::os::raw::c_int,
    pub hdr_refcount: ::std::os::raw::c_int,
    pub heap: *mut CvSet,
    pub hashtable: *mut *mut ::std::os::raw::c_void,
    pub hashsize: ::std::os::raw::c_int,
    pub valoffset: ::std::os::raw::c_int,
    pub idxoffset: ::std::os::raw::c_int,
    pub size: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_CvSparseMat() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseMat>(),
        184usize,
        concat!("Size of: ", stringify!(CvSparseMat))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseMat>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseMat))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).dims as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).refcount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).hdr_refcount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hdr_refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).heap as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).hashtable as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hashtable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).hashsize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(hashsize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).valoffset as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(valoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).idxoffset as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(idxoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMat>())).size as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMat),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseNode {
    pub hashval: ::std::os::raw::c_uint,
    pub next: *mut CvSparseNode,
}
#[test]
fn bindgen_test_layout_CvSparseNode() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseNode>(),
        16usize,
        concat!("Size of: ", stringify!(CvSparseNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseNode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseNode>())).hashval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseNode),
            "::",
            stringify!(hashval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseNode>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSparseMatIterator {
    pub mat: *mut CvSparseMat,
    pub node: *mut CvSparseNode,
    pub curidx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSparseMatIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvSparseMatIterator>(),
        24usize,
        concat!("Size of: ", stringify!(CvSparseMatIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSparseMatIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSparseMatIterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMatIterator>())).mat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(mat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMatIterator>())).node as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSparseMatIterator>())).curidx as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSparseMatIterator),
            "::",
            stringify!(curidx)
        )
    );
}
pub type CvHistType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvHistogram {
    pub type_: ::std::os::raw::c_int,
    pub bins: *mut CvArr,
    pub thresh: [[f32; 2usize]; 32usize],
    pub thresh2: *mut *mut f32,
    pub mat: CvMatND,
}
#[test]
fn bindgen_test_layout_CvHistogram() {
    assert_eq!(
        ::std::mem::size_of::<CvHistogram>(),
        568usize,
        concat!("Size of: ", stringify!(CvHistogram))
    );
    assert_eq!(
        ::std::mem::align_of::<CvHistogram>(),
        8usize,
        concat!("Alignment of ", stringify!(CvHistogram))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHistogram>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHistogram>())).bins as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(bins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHistogram>())).thresh as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHistogram>())).thresh2 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(thresh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHistogram>())).mat as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHistogram),
            "::",
            stringify!(mat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvRect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvRect() {
    assert_eq!(
        ::std::mem::size_of::<CvRect>(),
        16usize,
        concat!("Size of: ", stringify!(CvRect))
    );
    assert_eq!(
        ::std::mem::align_of::<CvRect>(),
        4usize,
        concat!("Alignment of ", stringify!(CvRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CvRect), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvRect>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(CvRect), "::", stringify!(y))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvRect>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvRect>())).height as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvRect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTermCriteria {
    pub type_: ::std::os::raw::c_int,
    pub max_iter: ::std::os::raw::c_int,
    pub epsilon: f64,
}
#[test]
fn bindgen_test_layout_CvTermCriteria() {
    assert_eq!(
        ::std::mem::size_of::<CvTermCriteria>(),
        16usize,
        concat!("Size of: ", stringify!(CvTermCriteria))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTermCriteria>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTermCriteria))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTermCriteria>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTermCriteria>())).max_iter as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(max_iter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTermCriteria>())).epsilon as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTermCriteria),
            "::",
            stringify!(epsilon)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvPoint() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint>(),
        8usize,
        concat!("Size of: ", stringify!(CvPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint2D32f {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_CvPoint2D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint2D32f>(),
        8usize,
        concat!("Size of: ", stringify!(CvPoint2D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint2D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint2D32f))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint2D32f>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D32f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint2D32f>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D32f),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint3D32f {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_CvPoint3D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint3D32f>(),
        12usize,
        concat!("Size of: ", stringify!(CvPoint3D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint3D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvPoint3D32f))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D32f>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D32f>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D32f>())).z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D32f),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint2D64f {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_CvPoint2D64f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint2D64f>(),
        16usize,
        concat!("Size of: ", stringify!(CvPoint2D64f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint2D64f>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPoint2D64f))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint2D64f>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D64f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint2D64f>())).y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint2D64f),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPoint3D64f {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_CvPoint3D64f() {
    assert_eq!(
        ::std::mem::size_of::<CvPoint3D64f>(),
        24usize,
        concat!("Size of: ", stringify!(CvPoint3D64f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPoint3D64f>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPoint3D64f))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D64f>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D64f>())).y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPoint3D64f>())).z as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPoint3D64f),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSize {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSize() {
    assert_eq!(
        ::std::mem::size_of::<CvSize>(),
        8usize,
        concat!("Size of: ", stringify!(CvSize))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSize>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSize))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSize>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSize>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSize2D32f {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_CvSize2D32f() {
    assert_eq!(
        ::std::mem::size_of::<CvSize2D32f>(),
        8usize,
        concat!("Size of: ", stringify!(CvSize2D32f))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSize2D32f>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSize2D32f))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSize2D32f>())).width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize2D32f),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSize2D32f>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSize2D32f),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvBox2D {
    pub center: CvPoint2D32f,
    pub size: CvSize2D32f,
    pub angle: f32,
}
#[test]
fn bindgen_test_layout_CvBox2D() {
    assert_eq!(
        ::std::mem::size_of::<CvBox2D>(),
        20usize,
        concat!("Size of: ", stringify!(CvBox2D))
    );
    assert_eq!(
        ::std::mem::align_of::<CvBox2D>(),
        4usize,
        concat!("Alignment of ", stringify!(CvBox2D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvBox2D>())).center as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvBox2D>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvBox2D>())).angle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvBox2D),
            "::",
            stringify!(angle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvLineIterator {
    pub ptr: *mut uchar,
    pub err: ::std::os::raw::c_int,
    pub plus_delta: ::std::os::raw::c_int,
    pub minus_delta: ::std::os::raw::c_int,
    pub plus_step: ::std::os::raw::c_int,
    pub minus_step: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvLineIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvLineIterator>(),
        32usize,
        concat!("Size of: ", stringify!(CvLineIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvLineIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvLineIterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).err as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).plus_delta as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(plus_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).minus_delta as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(minus_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).plus_step as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(plus_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvLineIterator>())).minus_step as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvLineIterator),
            "::",
            stringify!(minus_step)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSlice {
    pub start_index: ::std::os::raw::c_int,
    pub end_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSlice() {
    assert_eq!(
        ::std::mem::size_of::<CvSlice>(),
        8usize,
        concat!("Size of: ", stringify!(CvSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSlice>(),
        4usize,
        concat!("Alignment of ", stringify!(CvSlice))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSlice>())).start_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSlice),
            "::",
            stringify!(start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSlice>())).end_index as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSlice),
            "::",
            stringify!(end_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvScalar {
    pub val: [f64; 4usize],
}
#[test]
fn bindgen_test_layout_CvScalar() {
    assert_eq!(
        ::std::mem::size_of::<CvScalar>(),
        32usize,
        concat!("Size of: ", stringify!(CvScalar))
    );
    assert_eq!(
        ::std::mem::align_of::<CvScalar>(),
        8usize,
        concat!("Alignment of ", stringify!(CvScalar))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvScalar>())).val as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvScalar),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemBlock {
    pub prev: *mut CvMemBlock,
    pub next: *mut CvMemBlock,
}
#[test]
fn bindgen_test_layout_CvMemBlock() {
    assert_eq!(
        ::std::mem::size_of::<CvMemBlock>(),
        16usize,
        concat!("Size of: ", stringify!(CvMemBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemBlock>())).prev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemBlock>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemBlock),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemStorage {
    pub signature: ::std::os::raw::c_int,
    pub bottom: *mut CvMemBlock,
    pub top: *mut CvMemBlock,
    pub parent: *mut CvMemStorage,
    pub block_size: ::std::os::raw::c_int,
    pub free_space: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMemStorage() {
    assert_eq!(
        ::std::mem::size_of::<CvMemStorage>(),
        40usize,
        concat!("Size of: ", stringify!(CvMemStorage))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemStorage>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemStorage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).signature as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).bottom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).top as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).parent as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).block_size as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStorage>())).free_space as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStorage),
            "::",
            stringify!(free_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMemStoragePos {
    pub top: *mut CvMemBlock,
    pub free_space: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvMemStoragePos() {
    assert_eq!(
        ::std::mem::size_of::<CvMemStoragePos>(),
        16usize,
        concat!("Size of: ", stringify!(CvMemStoragePos))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMemStoragePos>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMemStoragePos))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStoragePos>())).top as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStoragePos),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMemStoragePos>())).free_space as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMemStoragePos),
            "::",
            stringify!(free_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqBlock {
    pub prev: *mut CvSeqBlock,
    pub next: *mut CvSeqBlock,
    pub start_index: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub data: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqBlock() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqBlock>(),
        32usize,
        concat!("Size of: ", stringify!(CvSeqBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqBlock))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqBlock>())).prev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqBlock>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqBlock>())).start_index as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqBlock>())).count as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqBlock>())).data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqBlock),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeq {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
}
#[test]
fn bindgen_test_layout_CvSeq() {
    assert_eq!(
        ::std::mem::size_of::<CvSeq>(),
        96usize,
        concat!("Size of: ", stringify!(CvSeq))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeq>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).header_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).h_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).h_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).v_prev as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).v_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).elem_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).block_max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).delta_elems as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).storage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeq>())).free_blocks as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSeq>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeq),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSetElem {
    pub flags: ::std::os::raw::c_int,
    pub next_free: *mut CvSetElem,
}
#[test]
fn bindgen_test_layout_CvSetElem() {
    assert_eq!(
        ::std::mem::size_of::<CvSetElem>(),
        16usize,
        concat!("Size of: ", stringify!(CvSetElem))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSetElem>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSetElem))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSetElem>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSetElem),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSetElem>())).next_free as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSetElem),
            "::",
            stringify!(next_free)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSet {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub free_elems: *mut CvSetElem,
    pub active_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvSet() {
    assert_eq!(
        ::std::mem::size_of::<CvSet>(),
        112usize,
        concat!("Size of: ", stringify!(CvSet))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSet>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).header_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).h_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).h_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).v_prev as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).v_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).total as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).elem_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).block_max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).delta_elems as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).storage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).free_blocks as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvSet>())).first as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).free_elems as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(free_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSet>())).active_count as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSet),
            "::",
            stringify!(active_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphEdge {
    pub flags: ::std::os::raw::c_int,
    pub weight: f32,
    pub next: [*mut CvGraphEdge; 2usize],
    pub vtx: [*mut CvGraphVtx; 2usize],
}
#[test]
fn bindgen_test_layout_CvGraphEdge() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphEdge>(),
        40usize,
        concat!("Size of: ", stringify!(CvGraphEdge))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphEdge>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphEdge))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphEdge>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphEdge>())).weight as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphEdge>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphEdge>())).vtx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphEdge),
            "::",
            stringify!(vtx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphVtx {
    pub flags: ::std::os::raw::c_int,
    pub first: *mut CvGraphEdge,
}
#[test]
fn bindgen_test_layout_CvGraphVtx() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphVtx>(),
        16usize,
        concat!("Size of: ", stringify!(CvGraphVtx))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphVtx>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphVtx))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphVtx>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphVtx>())).first as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphVtx2D {
    pub flags: ::std::os::raw::c_int,
    pub first: *mut CvGraphEdge,
    pub ptr: *mut CvPoint2D32f,
}
#[test]
fn bindgen_test_layout_CvGraphVtx2D() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphVtx2D>(),
        24usize,
        concat!("Size of: ", stringify!(CvGraphVtx2D))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphVtx2D>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphVtx2D))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphVtx2D>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphVtx2D>())).first as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphVtx2D>())).ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphVtx2D),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraph {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub free_elems: *mut CvSetElem,
    pub active_count: ::std::os::raw::c_int,
    pub edges: *mut CvSet,
}
#[test]
fn bindgen_test_layout_CvGraph() {
    assert_eq!(
        ::std::mem::size_of::<CvGraph>(),
        120usize,
        concat!("Size of: ", stringify!(CvGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraph))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).header_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).h_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).h_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).v_prev as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).v_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).total as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).elem_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).block_max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvGraph>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).delta_elems as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).storage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).free_blocks as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).first as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).free_elems as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(free_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).active_count as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(active_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraph>())).edges as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraph),
            "::",
            stringify!(edges)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvChain {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub origin: CvPoint,
}
#[test]
fn bindgen_test_layout_CvChain() {
    assert_eq!(
        ::std::mem::size_of::<CvChain>(),
        104usize,
        concat!("Size of: ", stringify!(CvChain))
    );
    assert_eq!(
        ::std::mem::align_of::<CvChain>(),
        8usize,
        concat!("Alignment of ", stringify!(CvChain))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).header_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).h_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).h_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).v_prev as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).v_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).total as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).elem_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).block_max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvChain>())).ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).delta_elems as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).storage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).free_blocks as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).first as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChain>())).origin as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChain),
            "::",
            stringify!(origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvContour {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub h_prev: *mut CvSeq,
    pub h_next: *mut CvSeq,
    pub v_prev: *mut CvSeq,
    pub v_next: *mut CvSeq,
    pub total: ::std::os::raw::c_int,
    pub elem_size: ::std::os::raw::c_int,
    pub block_max: *mut schar,
    pub ptr: *mut schar,
    pub delta_elems: ::std::os::raw::c_int,
    pub storage: *mut CvMemStorage,
    pub free_blocks: *mut CvSeqBlock,
    pub first: *mut CvSeqBlock,
    pub rect: CvRect,
    pub color: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_int; 3usize],
}
#[test]
fn bindgen_test_layout_CvContour() {
    assert_eq!(
        ::std::mem::size_of::<CvContour>(),
        128usize,
        concat!("Size of: ", stringify!(CvContour))
    );
    assert_eq!(
        ::std::mem::align_of::<CvContour>(),
        8usize,
        concat!("Alignment of ", stringify!(CvContour))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).header_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).h_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(h_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).h_next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(h_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).v_prev as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(v_prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).v_next as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(v_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).total as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).elem_size as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).block_max as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).ptr as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).delta_elems as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(delta_elems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).storage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).free_blocks as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(free_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).first as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).rect as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).color as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvContour>())).reserved as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(CvContour),
            "::",
            stringify!(reserved)
        )
    );
}
pub type CvPoint2DSeq = CvContour;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqWriter {
    pub header_size: ::std::os::raw::c_int,
    pub seq: *mut CvSeq,
    pub block: *mut CvSeqBlock,
    pub ptr: *mut schar,
    pub block_min: *mut schar,
    pub block_max: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqWriter() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqWriter>(),
        48usize,
        concat!("Size of: ", stringify!(CvSeqWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqWriter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).header_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).seq as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).block as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).block_min as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqWriter>())).block_max as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqWriter),
            "::",
            stringify!(block_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvSeqReader {
    pub header_size: ::std::os::raw::c_int,
    pub seq: *mut CvSeq,
    pub block: *mut CvSeqBlock,
    pub ptr: *mut schar,
    pub block_min: *mut schar,
    pub block_max: *mut schar,
    pub delta_index: ::std::os::raw::c_int,
    pub prev_elem: *mut schar,
}
#[test]
fn bindgen_test_layout_CvSeqReader() {
    assert_eq!(
        ::std::mem::size_of::<CvSeqReader>(),
        64usize,
        concat!("Size of: ", stringify!(CvSeqReader))
    );
    assert_eq!(
        ::std::mem::align_of::<CvSeqReader>(),
        8usize,
        concat!("Alignment of ", stringify!(CvSeqReader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).header_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).seq as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).block as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).block_min as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).block_max as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).delta_index as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(delta_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvSeqReader>())).prev_elem as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvSeqReader),
            "::",
            stringify!(prev_elem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvFileStorage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvAttrList {
    pub attr: *mut *const ::std::os::raw::c_char,
    pub next: *mut CvAttrList,
}
#[test]
fn bindgen_test_layout_CvAttrList() {
    assert_eq!(
        ::std::mem::size_of::<CvAttrList>(),
        16usize,
        concat!("Size of: ", stringify!(CvAttrList))
    );
    assert_eq!(
        ::std::mem::align_of::<CvAttrList>(),
        8usize,
        concat!("Alignment of ", stringify!(CvAttrList))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvAttrList>())).attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvAttrList),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvAttrList>())).next as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvAttrList),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvString {
    pub len: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CvString() {
    assert_eq!(
        ::std::mem::size_of::<CvString>(),
        16usize,
        concat!("Size of: ", stringify!(CvString))
    );
    assert_eq!(
        ::std::mem::align_of::<CvString>(),
        8usize,
        concat!("Alignment of ", stringify!(CvString))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvString>())).len as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvString>())).ptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvString),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvStringHashNode {
    pub hashval: ::std::os::raw::c_uint,
    pub str: CvString,
    pub next: *mut CvStringHashNode,
}
#[test]
fn bindgen_test_layout_CvStringHashNode() {
    assert_eq!(
        ::std::mem::size_of::<CvStringHashNode>(),
        32usize,
        concat!("Size of: ", stringify!(CvStringHashNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvStringHashNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvStringHashNode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvStringHashNode>())).hashval as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(hashval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvStringHashNode>())).str as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvStringHashNode>())).next as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvStringHashNode),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGenericHash {
    _unused: [u8; 0],
}
pub type CvFileNodeHash = CvGenericHash;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CvFileNode {
    pub tag: ::std::os::raw::c_int,
    pub info: *mut CvTypeInfo,
    pub data: CvFileNode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CvFileNode__bindgen_ty_1 {
    pub f: f64,
    pub i: ::std::os::raw::c_int,
    pub str: CvString,
    pub seq: *mut CvSeq,
    pub map: *mut CvFileNodeHash,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_CvFileNode__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CvFileNode__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CvFileNode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CvFileNode__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CvFileNode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).f as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).i as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).str as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).seq as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode__bindgen_ty_1>())).map as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
}
#[test]
fn bindgen_test_layout_CvFileNode() {
    assert_eq!(
        ::std::mem::size_of::<CvFileNode>(),
        32usize,
        concat!("Size of: ", stringify!(CvFileNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CvFileNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CvFileNode))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode>())).tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode>())).info as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFileNode>())).data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFileNode),
            "::",
            stringify!(data)
        )
    );
}
pub type CvIsInstanceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        struct_ptr: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type CvReleaseFunc = ::std::option::Option<
    unsafe extern "C" fn(struct_dblptr: *mut *mut ::std::os::raw::c_void),
>;
pub type CvReadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        storage: *mut CvFileStorage,
        node: *mut CvFileNode,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type CvWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        storage: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        struct_ptr: *const ::std::os::raw::c_void,
        attributes: CvAttrList,
    ),
>;
pub type CvCloneFunc = ::std::option::Option<
    unsafe extern "C" fn(
        struct_ptr: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTypeInfo {
    pub flags: ::std::os::raw::c_int,
    pub header_size: ::std::os::raw::c_int,
    pub prev: *mut CvTypeInfo,
    pub next: *mut CvTypeInfo,
    pub type_name: *const ::std::os::raw::c_char,
    pub is_instance: CvIsInstanceFunc,
    pub release: CvReleaseFunc,
    pub read: CvReadFunc,
    pub write: CvWriteFunc,
    pub clone: CvCloneFunc,
}
#[test]
fn bindgen_test_layout_CvTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(CvTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTypeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).header_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).type_name as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).is_instance as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(is_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).release as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).read as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).write as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTypeInfo>())).clone as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTypeInfo),
            "::",
            stringify!(clone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvPluginFuncInfo {
    pub func_addr: *mut *mut ::std::os::raw::c_void,
    pub default_func_addr: *mut ::std::os::raw::c_void,
    pub func_names: *const ::std::os::raw::c_char,
    pub search_modules: ::std::os::raw::c_int,
    pub loaded_from: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvPluginFuncInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvPluginFuncInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CvPluginFuncInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvPluginFuncInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvPluginFuncInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPluginFuncInfo>())).func_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(func_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPluginFuncInfo>())).default_func_addr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(default_func_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPluginFuncInfo>())).func_names as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(func_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPluginFuncInfo>())).search_modules
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(search_modules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvPluginFuncInfo>())).loaded_from as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CvPluginFuncInfo),
            "::",
            stringify!(loaded_from)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvModuleInfo {
    pub next: *mut CvModuleInfo,
    pub name: *const ::std::os::raw::c_char,
    pub version: *const ::std::os::raw::c_char,
    pub func_tab: *mut CvPluginFuncInfo,
}
#[test]
fn bindgen_test_layout_CvModuleInfo() {
    assert_eq!(
        ::std::mem::size_of::<CvModuleInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CvModuleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CvModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CvModuleInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvModuleInfo>())).next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvModuleInfo>())).name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvModuleInfo>())).version as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvModuleInfo>())).func_tab as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvModuleInfo),
            "::",
            stringify!(func_tab)
        )
    );
}
extern "C" {
    pub fn cvAlloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvFree_(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cvCreateImageHeader(
        size: CvSize,
        depth: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    ) -> *mut IplImage;
}
extern "C" {
    pub fn cvInitImageHeader(
        image: *mut IplImage,
        size: CvSize,
        depth: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
        align: ::std::os::raw::c_int,
    ) -> *mut IplImage;
}
extern "C" {
    pub fn cvCreateImage(
        size: CvSize,
        depth: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    ) -> *mut IplImage;
}
extern "C" {
    pub fn cvReleaseImageHeader(image: *mut *mut IplImage);
}
extern "C" {
    pub fn cvReleaseImage(image: *mut *mut IplImage);
}
extern "C" {
    pub fn cvCloneImage(image: *const IplImage) -> *mut IplImage;
}
extern "C" {
    pub fn cvSetImageCOI(image: *mut IplImage, coi: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvGetImageCOI(image: *const IplImage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetImageROI(image: *mut IplImage, rect: CvRect);
}
extern "C" {
    pub fn cvResetImageROI(image: *mut IplImage);
}
extern "C" {
    pub fn cvGetImageROI(image: *const IplImage) -> CvRect;
}
extern "C" {
    pub fn cvCreateMatHeader(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvInitMatHeader(
        mat: *mut CvMat,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        step: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvCreateMat(
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvReleaseMat(mat: *mut *mut CvMat);
}
extern "C" {
    pub fn cvCloneMat(mat: *const CvMat) -> *mut CvMat;
}
extern "C" {
    pub fn cvGetSubRect(
        arr: *const CvArr,
        submat: *mut CvMat,
        rect: CvRect,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvGetRows(
        arr: *const CvArr,
        submat: *mut CvMat,
        start_row: ::std::os::raw::c_int,
        end_row: ::std::os::raw::c_int,
        delta_row: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvGetCols(
        arr: *const CvArr,
        submat: *mut CvMat,
        start_col: ::std::os::raw::c_int,
        end_col: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvGetDiag(
        arr: *const CvArr,
        submat: *mut CvMat,
        diag: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvScalarToRawData(
        scalar: *const CvScalar,
        data: *mut ::std::os::raw::c_void,
        type_: ::std::os::raw::c_int,
        extend_to_12: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvRawDataToScalar(
        data: *const ::std::os::raw::c_void,
        type_: ::std::os::raw::c_int,
        scalar: *mut CvScalar,
    );
}
extern "C" {
    pub fn cvCreateMatNDHeader(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMatND;
}
extern "C" {
    pub fn cvCreateMatND(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvMatND;
}
extern "C" {
    pub fn cvInitMatNDHeader(
        mat: *mut CvMatND,
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut CvMatND;
}
extern "C" {
    pub fn cvCloneMatND(mat: *const CvMatND) -> *mut CvMatND;
}
extern "C" {
    pub fn cvCreateSparseMat(
        dims: ::std::os::raw::c_int,
        sizes: *const ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CvSparseMat;
}
extern "C" {
    pub fn cvReleaseSparseMat(mat: *mut *mut CvSparseMat);
}
extern "C" {
    pub fn cvCloneSparseMat(mat: *const CvSparseMat) -> *mut CvSparseMat;
}
extern "C" {
    pub fn cvInitSparseMatIterator(
        mat: *const CvSparseMat,
        mat_iterator: *mut CvSparseMatIterator,
    ) -> *mut CvSparseNode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvNArrayIterator {
    pub count: ::std::os::raw::c_int,
    pub dims: ::std::os::raw::c_int,
    pub size: CvSize,
    pub ptr: [*mut uchar; 10usize],
    pub stack: [::std::os::raw::c_int; 32usize],
    pub hdr: [*mut CvMatND; 10usize],
}
#[test]
fn bindgen_test_layout_CvNArrayIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvNArrayIterator>(),
        304usize,
        concat!("Size of: ", stringify!(CvNArrayIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvNArrayIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvNArrayIterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).dims as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).ptr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).stack as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvNArrayIterator>())).hdr as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CvNArrayIterator),
            "::",
            stringify!(hdr)
        )
    );
}
extern "C" {
    pub fn cvInitNArrayIterator(
        count: ::std::os::raw::c_int,
        arrs: *mut *mut CvArr,
        mask: *const CvArr,
        stubs: *mut CvMatND,
        array_iterator: *mut CvNArrayIterator,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvNextNArraySlice(
        array_iterator: *mut CvNArrayIterator,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGetElemType(arr: *const CvArr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGetDims(
        arr: *const CvArr,
        sizes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGetDimSize(
        arr: *const CvArr,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvPtr1D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut uchar;
}
extern "C" {
    pub fn cvPtr2D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut uchar;
}
extern "C" {
    pub fn cvPtr3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
    ) -> *mut uchar;
}
extern "C" {
    pub fn cvPtrND(
        arr: *const CvArr,
        idx: *const ::std::os::raw::c_int,
        type_: *mut ::std::os::raw::c_int,
        create_node: ::std::os::raw::c_int,
        precalc_hashval: *mut ::std::os::raw::c_uint,
    ) -> *mut uchar;
}
extern "C" {
    pub fn cvGet1D(arr: *const CvArr, idx0: ::std::os::raw::c_int) -> CvScalar;
}
extern "C" {
    pub fn cvGet2D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
    ) -> CvScalar;
}
extern "C" {
    pub fn cvGet3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> CvScalar;
}
extern "C" {
    pub fn cvGetND(
        arr: *const CvArr,
        idx: *const ::std::os::raw::c_int,
    ) -> CvScalar;
}
extern "C" {
    pub fn cvGetReal1D(arr: *const CvArr, idx0: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn cvGetReal2D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn cvGetReal3D(
        arr: *const CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn cvGetRealND(
        arr: *const CvArr,
        idx: *const ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn cvSet1D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    pub fn cvSet2D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    pub fn cvSet3D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    pub fn cvSetND(
        arr: *mut CvArr,
        idx: *const ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    pub fn cvSetReal1D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn cvSetReal2D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn cvSetReal3D(
        arr: *mut CvArr,
        idx0: ::std::os::raw::c_int,
        idx1: ::std::os::raw::c_int,
        idx2: ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn cvSetRealND(
        arr: *mut CvArr,
        idx: *const ::std::os::raw::c_int,
        value: f64,
    );
}
extern "C" {
    pub fn cvClearND(arr: *mut CvArr, idx: *const ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvGetMat(
        arr: *const CvArr,
        header: *mut CvMat,
        coi: *mut ::std::os::raw::c_int,
        allowND: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvGetImage(
        arr: *const CvArr,
        image_header: *mut IplImage,
    ) -> *mut IplImage;
}
extern "C" {
    pub fn cvReshapeMatND(
        arr: *const CvArr,
        sizeof_header: ::std::os::raw::c_int,
        header: *mut CvArr,
        new_cn: ::std::os::raw::c_int,
        new_dims: ::std::os::raw::c_int,
        new_sizes: *mut ::std::os::raw::c_int,
    ) -> *mut CvArr;
}
extern "C" {
    pub fn cvReshape(
        arr: *const CvArr,
        header: *mut CvMat,
        new_cn: ::std::os::raw::c_int,
        new_rows: ::std::os::raw::c_int,
    ) -> *mut CvMat;
}
extern "C" {
    pub fn cvRepeat(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvCreateData(arr: *mut CvArr);
}
extern "C" {
    pub fn cvReleaseData(arr: *mut CvArr);
}
extern "C" {
    pub fn cvSetData(
        arr: *mut CvArr,
        data: *mut ::std::os::raw::c_void,
        step: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvGetRawData(
        arr: *const CvArr,
        data: *mut *mut uchar,
        step: *mut ::std::os::raw::c_int,
        roi_size: *mut CvSize,
    );
}
extern "C" {
    pub fn cvGetSize(arr: *const CvArr) -> CvSize;
}
extern "C" {
    pub fn cvCopy(src: *const CvArr, dst: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    pub fn cvSet(arr: *mut CvArr, value: CvScalar, mask: *const CvArr);
}
extern "C" {
    pub fn cvSetZero(arr: *mut CvArr);
}
extern "C" {
    pub fn cvSplit(
        src: *const CvArr,
        dst0: *mut CvArr,
        dst1: *mut CvArr,
        dst2: *mut CvArr,
        dst3: *mut CvArr,
    );
}
extern "C" {
    pub fn cvMerge(
        src0: *const CvArr,
        src1: *const CvArr,
        src2: *const CvArr,
        src3: *const CvArr,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvMixChannels(
        src: *mut *const CvArr,
        src_count: ::std::os::raw::c_int,
        dst: *mut *mut CvArr,
        dst_count: ::std::os::raw::c_int,
        from_to: *const ::std::os::raw::c_int,
        pair_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvConvertScale(
        src: *const CvArr,
        dst: *mut CvArr,
        scale: f64,
        shift: f64,
    );
}
extern "C" {
    pub fn cvConvertScaleAbs(
        src: *const CvArr,
        dst: *mut CvArr,
        scale: f64,
        shift: f64,
    );
}
extern "C" {
    pub fn cvCheckTermCriteria(
        criteria: CvTermCriteria,
        default_eps: f64,
        default_max_iters: ::std::os::raw::c_int,
    ) -> CvTermCriteria;
}
extern "C" {
    pub fn cvAdd(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvAddS(
        src: *const CvArr,
        value: CvScalar,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvSub(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvSubRS(
        src: *const CvArr,
        value: CvScalar,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvMul(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        scale: f64,
    );
}
extern "C" {
    pub fn cvDiv(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        scale: f64,
    );
}
extern "C" {
    pub fn cvScaleAdd(
        src1: *const CvArr,
        scale: CvScalar,
        src2: *const CvArr,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvAddWeighted(
        src1: *const CvArr,
        alpha: f64,
        src2: *const CvArr,
        beta: f64,
        gamma: f64,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvDotProduct(src1: *const CvArr, src2: *const CvArr) -> f64;
}
extern "C" {
    pub fn cvAnd(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvAndS(
        src: *const CvArr,
        value: CvScalar,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvOr(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvOrS(
        src: *const CvArr,
        value: CvScalar,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvXor(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvXorS(
        src: *const CvArr,
        value: CvScalar,
        dst: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvNot(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvInRange(
        src: *const CvArr,
        lower: *const CvArr,
        upper: *const CvArr,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvInRangeS(
        src: *const CvArr,
        lower: CvScalar,
        upper: CvScalar,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvCmp(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        cmp_op: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCmpS(
        src: *const CvArr,
        value: f64,
        dst: *mut CvArr,
        cmp_op: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvMin(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvMax(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvMinS(src: *const CvArr, value: f64, dst: *mut CvArr);
}
extern "C" {
    pub fn cvMaxS(src: *const CvArr, value: f64, dst: *mut CvArr);
}
extern "C" {
    pub fn cvAbsDiff(src1: *const CvArr, src2: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvAbsDiffS(src: *const CvArr, dst: *mut CvArr, value: CvScalar);
}
extern "C" {
    pub fn cvCartToPolar(
        x: *const CvArr,
        y: *const CvArr,
        magnitude: *mut CvArr,
        angle: *mut CvArr,
        angle_in_degrees: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvPolarToCart(
        magnitude: *const CvArr,
        angle: *const CvArr,
        x: *mut CvArr,
        y: *mut CvArr,
        angle_in_degrees: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvPow(src: *const CvArr, dst: *mut CvArr, power: f64);
}
extern "C" {
    pub fn cvExp(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvLog(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvFastArctan(y: f32, x: f32) -> f32;
}
extern "C" {
    pub fn cvCbrt(value: f32) -> f32;
}
extern "C" {
    pub fn cvCheckArr(
        arr: *const CvArr,
        flags: ::std::os::raw::c_int,
        min_val: f64,
        max_val: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvRandArr(
        rng: *mut CvRNG,
        arr: *mut CvArr,
        dist_type: ::std::os::raw::c_int,
        param1: CvScalar,
        param2: CvScalar,
    );
}
extern "C" {
    pub fn cvRandShuffle(mat: *mut CvArr, rng: *mut CvRNG, iter_factor: f64);
}
extern "C" {
    pub fn cvSort(
        src: *const CvArr,
        dst: *mut CvArr,
        idxmat: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSolveCubic(
        coeffs: *const CvMat,
        roots: *mut CvMat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSolvePoly(
        coeffs: *const CvMat,
        roots2: *mut CvMat,
        maxiter: ::std::os::raw::c_int,
        fig: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCrossProduct(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
    );
}
extern "C" {
    pub fn cvGEMM(
        src1: *const CvArr,
        src2: *const CvArr,
        alpha: f64,
        src3: *const CvArr,
        beta: f64,
        dst: *mut CvArr,
        tABC: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvTransform(
        src: *const CvArr,
        dst: *mut CvArr,
        transmat: *const CvMat,
        shiftvec: *const CvMat,
    );
}
extern "C" {
    pub fn cvPerspectiveTransform(
        src: *const CvArr,
        dst: *mut CvArr,
        mat: *const CvMat,
    );
}
extern "C" {
    pub fn cvMulTransposed(
        src: *const CvArr,
        dst: *mut CvArr,
        order: ::std::os::raw::c_int,
        delta: *const CvArr,
        scale: f64,
    );
}
extern "C" {
    pub fn cvTranspose(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    pub fn cvCompleteSymm(matrix: *mut CvMat, LtoR: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvFlip(
        src: *const CvArr,
        dst: *mut CvArr,
        flip_mode: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSVD(
        A: *mut CvArr,
        W: *mut CvArr,
        U: *mut CvArr,
        V: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSVBkSb(
        W: *const CvArr,
        U: *const CvArr,
        V: *const CvArr,
        B: *const CvArr,
        X: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvInvert(
        src: *const CvArr,
        dst: *mut CvArr,
        method: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn cvSolve(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        method: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvDet(mat: *const CvArr) -> f64;
}
extern "C" {
    pub fn cvTrace(mat: *const CvArr) -> CvScalar;
}
extern "C" {
    pub fn cvEigenVV(
        mat: *mut CvArr,
        evects: *mut CvArr,
        evals: *mut CvArr,
        eps: f64,
        lowindex: ::std::os::raw::c_int,
        highindex: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSetIdentity(mat: *mut CvArr, value: CvScalar);
}
extern "C" {
    pub fn cvRange(mat: *mut CvArr, start: f64, end: f64) -> *mut CvArr;
}
extern "C" {
    pub fn cvCalcCovarMatrix(
        vects: *mut *const CvArr,
        count: ::std::os::raw::c_int,
        cov_mat: *mut CvArr,
        avg: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCalcPCA(
        data: *const CvArr,
        mean: *mut CvArr,
        eigenvals: *mut CvArr,
        eigenvects: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvProjectPCA(
        data: *const CvArr,
        mean: *const CvArr,
        eigenvects: *const CvArr,
        result: *mut CvArr,
    );
}
extern "C" {
    pub fn cvBackProjectPCA(
        proj: *const CvArr,
        mean: *const CvArr,
        eigenvects: *const CvArr,
        result: *mut CvArr,
    );
}
extern "C" {
    pub fn cvMahalanobis(
        vec1: *const CvArr,
        vec2: *const CvArr,
        mat: *const CvArr,
    ) -> f64;
}
extern "C" {
    pub fn cvSum(arr: *const CvArr) -> CvScalar;
}
extern "C" {
    pub fn cvCountNonZero(arr: *const CvArr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvAvg(arr: *const CvArr, mask: *const CvArr) -> CvScalar;
}
extern "C" {
    pub fn cvAvgSdv(
        arr: *const CvArr,
        mean: *mut CvScalar,
        std_dev: *mut CvScalar,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvMinMaxLoc(
        arr: *const CvArr,
        min_val: *mut f64,
        max_val: *mut f64,
        min_loc: *mut CvPoint,
        max_loc: *mut CvPoint,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvNorm(
        arr1: *const CvArr,
        arr2: *const CvArr,
        norm_type: ::std::os::raw::c_int,
        mask: *const CvArr,
    ) -> f64;
}
extern "C" {
    pub fn cvNormalize(
        src: *const CvArr,
        dst: *mut CvArr,
        a: f64,
        b: f64,
        norm_type: ::std::os::raw::c_int,
        mask: *const CvArr,
    );
}
extern "C" {
    pub fn cvReduce(
        src: *const CvArr,
        dst: *mut CvArr,
        dim: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvDFT(
        src: *const CvArr,
        dst: *mut CvArr,
        flags: ::std::os::raw::c_int,
        nonzero_rows: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvMulSpectrums(
        src1: *const CvArr,
        src2: *const CvArr,
        dst: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvGetOptimalDFTSize(
        size0: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvDCT(
        src: *const CvArr,
        dst: *mut CvArr,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSliceLength(
        slice: CvSlice,
        seq: *const CvSeq,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvCreateMemStorage(
        block_size: ::std::os::raw::c_int,
    ) -> *mut CvMemStorage;
}
extern "C" {
    pub fn cvCreateChildMemStorage(
        parent: *mut CvMemStorage,
    ) -> *mut CvMemStorage;
}
extern "C" {
    pub fn cvReleaseMemStorage(storage: *mut *mut CvMemStorage);
}
extern "C" {
    pub fn cvClearMemStorage(storage: *mut CvMemStorage);
}
extern "C" {
    pub fn cvSaveMemStoragePos(
        storage: *const CvMemStorage,
        pos: *mut CvMemStoragePos,
    );
}
extern "C" {
    pub fn cvRestoreMemStoragePos(
        storage: *mut CvMemStorage,
        pos: *mut CvMemStoragePos,
    );
}
extern "C" {
    pub fn cvMemStorageAlloc(
        storage: *mut CvMemStorage,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvMemStorageAllocString(
        storage: *mut CvMemStorage,
        ptr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> CvString;
}
extern "C" {
    pub fn cvCreateSeq(
        seq_flags: ::std::os::raw::c_int,
        header_size: usize,
        elem_size: usize,
        storage: *mut CvMemStorage,
    ) -> *mut CvSeq;
}
extern "C" {
    pub fn cvSetSeqBlockSize(
        seq: *mut CvSeq,
        delta_elems: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSeqPush(
        seq: *mut CvSeq,
        element: *const ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    pub fn cvSeqPushFront(
        seq: *mut CvSeq,
        element: *const ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    pub fn cvSeqPop(seq: *mut CvSeq, element: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cvSeqPopFront(seq: *mut CvSeq, element: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cvSeqPushMulti(
        seq: *mut CvSeq,
        elements: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_int,
        in_front: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSeqPopMulti(
        seq: *mut CvSeq,
        elements: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_int,
        in_front: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvSeqInsert(
        seq: *mut CvSeq,
        before_index: ::std::os::raw::c_int,
        element: *const ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    pub fn cvSeqRemove(seq: *mut CvSeq, index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvClearSeq(seq: *mut CvSeq);
}
extern "C" {
    pub fn cvGetSeqElem(
        seq: *const CvSeq,
        index: ::std::os::raw::c_int,
    ) -> *mut schar;
}
extern "C" {
    pub fn cvSeqElemIdx(
        seq: *const CvSeq,
        element: *const ::std::os::raw::c_void,
        block: *mut *mut CvSeqBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvStartAppendToSeq(seq: *mut CvSeq, writer: *mut CvSeqWriter);
}
extern "C" {
    pub fn cvStartWriteSeq(
        seq_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
        writer: *mut CvSeqWriter,
    );
}
extern "C" {
    pub fn cvEndWriteSeq(writer: *mut CvSeqWriter) -> *mut CvSeq;
}
extern "C" {
    pub fn cvFlushSeqWriter(writer: *mut CvSeqWriter);
}
extern "C" {
    pub fn cvStartReadSeq(
        seq: *const CvSeq,
        reader: *mut CvSeqReader,
        reverse: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvGetSeqReaderPos(reader: *mut CvSeqReader)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetSeqReaderPos(
        reader: *mut CvSeqReader,
        index: ::std::os::raw::c_int,
        is_relative: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCvtSeqToArray(
        seq: *const CvSeq,
        elements: *mut ::std::os::raw::c_void,
        slice: CvSlice,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvMakeSeqHeaderForArray(
        seq_type: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        elements: *mut ::std::os::raw::c_void,
        total: ::std::os::raw::c_int,
        seq: *mut CvSeq,
        block: *mut CvSeqBlock,
    ) -> *mut CvSeq;
}
extern "C" {
    pub fn cvSeqSlice(
        seq: *const CvSeq,
        slice: CvSlice,
        storage: *mut CvMemStorage,
        copy_data: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    pub fn cvSeqRemoveSlice(seq: *mut CvSeq, slice: CvSlice);
}
extern "C" {
    pub fn cvSeqInsertSlice(
        seq: *mut CvSeq,
        before_index: ::std::os::raw::c_int,
        from_arr: *const CvArr,
    );
}
pub type CvCmpFunc = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn cvSeqSort(
        seq: *mut CvSeq,
        func: CvCmpFunc,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn cvSeqSearch(
        seq: *mut CvSeq,
        elem: *const ::std::os::raw::c_void,
        func: CvCmpFunc,
        is_sorted: ::std::os::raw::c_int,
        elem_idx: *mut ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut schar;
}
extern "C" {
    pub fn cvSeqInvert(seq: *mut CvSeq);
}
extern "C" {
    pub fn cvSeqPartition(
        seq: *const CvSeq,
        storage: *mut CvMemStorage,
        labels: *mut *mut CvSeq,
        is_equal: CvCmpFunc,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvChangeSeqBlock(
        reader: *mut ::std::os::raw::c_void,
        direction: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvCreateSeqBlock(writer: *mut CvSeqWriter);
}
extern "C" {
    pub fn cvCreateSet(
        set_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        elem_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvSet;
}
extern "C" {
    pub fn cvSetAdd(
        set_header: *mut CvSet,
        elem: *mut CvSetElem,
        inserted_elem: *mut *mut CvSetElem,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetRemove(set_header: *mut CvSet, index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvClearSet(set_header: *mut CvSet);
}
extern "C" {
    pub fn cvCreateGraph(
        graph_flags: ::std::os::raw::c_int,
        header_size: ::std::os::raw::c_int,
        vtx_size: ::std::os::raw::c_int,
        edge_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvGraph;
}
extern "C" {
    pub fn cvGraphAddVtx(
        graph: *mut CvGraph,
        vtx: *const CvGraphVtx,
        inserted_vtx: *mut *mut CvGraphVtx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphRemoveVtx(
        graph: *mut CvGraph,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphRemoveVtxByPtr(
        graph: *mut CvGraph,
        vtx: *mut CvGraphVtx,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphAddEdge(
        graph: *mut CvGraph,
        start_idx: ::std::os::raw::c_int,
        end_idx: ::std::os::raw::c_int,
        edge: *const CvGraphEdge,
        inserted_edge: *mut *mut CvGraphEdge,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphAddEdgeByPtr(
        graph: *mut CvGraph,
        start_vtx: *mut CvGraphVtx,
        end_vtx: *mut CvGraphVtx,
        edge: *const CvGraphEdge,
        inserted_edge: *mut *mut CvGraphEdge,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphRemoveEdge(
        graph: *mut CvGraph,
        start_idx: ::std::os::raw::c_int,
        end_idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvGraphRemoveEdgeByPtr(
        graph: *mut CvGraph,
        start_vtx: *mut CvGraphVtx,
        end_vtx: *mut CvGraphVtx,
    );
}
extern "C" {
    pub fn cvFindGraphEdge(
        graph: *const CvGraph,
        start_idx: ::std::os::raw::c_int,
        end_idx: ::std::os::raw::c_int,
    ) -> *mut CvGraphEdge;
}
extern "C" {
    pub fn cvFindGraphEdgeByPtr(
        graph: *const CvGraph,
        start_vtx: *const CvGraphVtx,
        end_vtx: *const CvGraphVtx,
    ) -> *mut CvGraphEdge;
}
extern "C" {
    pub fn cvClearGraph(graph: *mut CvGraph);
}
extern "C" {
    pub fn cvGraphVtxDegree(
        graph: *const CvGraph,
        vtx_idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGraphVtxDegreeByPtr(
        graph: *const CvGraph,
        vtx: *const CvGraphVtx,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvGraphScanner {
    pub vtx: *mut CvGraphVtx,
    pub dst: *mut CvGraphVtx,
    pub edge: *mut CvGraphEdge,
    pub graph: *mut CvGraph,
    pub stack: *mut CvSeq,
    pub index: ::std::os::raw::c_int,
    pub mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvGraphScanner() {
    assert_eq!(
        ::std::mem::size_of::<CvGraphScanner>(),
        48usize,
        concat!("Size of: ", stringify!(CvGraphScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<CvGraphScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(CvGraphScanner))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).vtx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(vtx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).dst as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).edge as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(edge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).graph as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).stack as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).index as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvGraphScanner>())).mask as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CvGraphScanner),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    pub fn cvCreateGraphScanner(
        graph: *mut CvGraph,
        vtx: *mut CvGraphVtx,
        mask: ::std::os::raw::c_int,
    ) -> *mut CvGraphScanner;
}
extern "C" {
    pub fn cvReleaseGraphScanner(scanner: *mut *mut CvGraphScanner);
}
extern "C" {
    pub fn cvNextGraphItem(
        scanner: *mut CvGraphScanner,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvCloneGraph(
        graph: *const CvGraph,
        storage: *mut CvMemStorage,
    ) -> *mut CvGraph;
}
extern "C" {
    pub fn cvLUT(src: *const CvArr, dst: *mut CvArr, lut: *const CvArr);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvTreeNodeIterator {
    pub node: *const ::std::os::raw::c_void,
    pub level: ::std::os::raw::c_int,
    pub max_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvTreeNodeIterator() {
    assert_eq!(
        ::std::mem::size_of::<CvTreeNodeIterator>(),
        16usize,
        concat!("Size of: ", stringify!(CvTreeNodeIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<CvTreeNodeIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(CvTreeNodeIterator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTreeNodeIterator>())).node as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTreeNodeIterator>())).level as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvTreeNodeIterator>())).max_level as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CvTreeNodeIterator),
            "::",
            stringify!(max_level)
        )
    );
}
extern "C" {
    pub fn cvInitTreeNodeIterator(
        tree_iterator: *mut CvTreeNodeIterator,
        first: *const ::std::os::raw::c_void,
        max_level: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvNextTreeNode(
        tree_iterator: *mut CvTreeNodeIterator,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvPrevTreeNode(
        tree_iterator: *mut CvTreeNodeIterator,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvInsertNodeIntoTree(
        node: *mut ::std::os::raw::c_void,
        parent: *mut ::std::os::raw::c_void,
        frame: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn cvRemoveNodeFromTree(
        node: *mut ::std::os::raw::c_void,
        frame: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn cvTreeToNodeSeq(
        first: *const ::std::os::raw::c_void,
        header_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
    ) -> *mut CvSeq;
}
extern "C" {
    pub fn cvKMeans2(
        samples: *const CvArr,
        cluster_count: ::std::os::raw::c_int,
        labels: *mut CvArr,
        termcrit: CvTermCriteria,
        attempts: ::std::os::raw::c_int,
        rng: *mut CvRNG,
        flags: ::std::os::raw::c_int,
        _centers: *mut CvArr,
        compactness: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvUseOptimized(
        on_off: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type Cv_iplCreateImageHeader = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
        arg6: ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
        arg8: ::std::os::raw::c_int,
        arg9: ::std::os::raw::c_int,
        arg10: ::std::os::raw::c_int,
        arg11: *mut IplROI,
        arg12: *mut IplImage,
        arg13: *mut ::std::os::raw::c_void,
        arg14: *mut IplTileInfo,
    ) -> *mut IplImage,
>;
pub type Cv_iplAllocateImageData = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut IplImage,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ),
>;
pub type Cv_iplDeallocate = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut IplImage, arg2: ::std::os::raw::c_int),
>;
pub type Cv_iplCreateROI = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> *mut IplROI,
>;
pub type Cv_iplCloneImage = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const IplImage) -> *mut IplImage,
>;
extern "C" {
    pub fn cvSetIPLAllocators(
        create_header: Cv_iplCreateImageHeader,
        allocate_data: Cv_iplAllocateImageData,
        deallocate: Cv_iplDeallocate,
        create_roi: Cv_iplCreateROI,
        clone_image: Cv_iplCloneImage,
    );
}
extern "C" {
    pub fn cvOpenFileStorage(
        filename: *const ::std::os::raw::c_char,
        memstorage: *mut CvMemStorage,
        flags: ::std::os::raw::c_int,
        encoding: *const ::std::os::raw::c_char,
    ) -> *mut CvFileStorage;
}
extern "C" {
    pub fn cvReleaseFileStorage(fs: *mut *mut CvFileStorage);
}
extern "C" {
    pub fn cvAttrValue(
        attr: *const CvAttrList,
        attr_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cvStartWriteStruct(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        struct_flags: ::std::os::raw::c_int,
        type_name: *const ::std::os::raw::c_char,
        attributes: CvAttrList,
    );
}
extern "C" {
    pub fn cvEndWriteStruct(fs: *mut CvFileStorage);
}
extern "C" {
    pub fn cvWriteInt(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvWriteReal(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        value: f64,
    );
}
extern "C" {
    pub fn cvWriteString(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        str: *const ::std::os::raw::c_char,
        quote: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvWriteComment(
        fs: *mut CvFileStorage,
        comment: *const ::std::os::raw::c_char,
        eol_comment: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvWrite(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        ptr: *const ::std::os::raw::c_void,
        attributes: CvAttrList,
    );
}
extern "C" {
    pub fn cvStartNextStream(fs: *mut CvFileStorage);
}
extern "C" {
    pub fn cvWriteRawData(
        fs: *mut CvFileStorage,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cvWriteRawDataBase64(
        fs: *mut CvFileStorage,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cvGetHashedKey(
        fs: *mut CvFileStorage,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        create_missing: ::std::os::raw::c_int,
    ) -> *mut CvStringHashNode;
}
extern "C" {
    pub fn cvGetRootFileNode(
        fs: *const CvFileStorage,
        stream_index: ::std::os::raw::c_int,
    ) -> *mut CvFileNode;
}
extern "C" {
    pub fn cvGetFileNode(
        fs: *mut CvFileStorage,
        map: *mut CvFileNode,
        key: *const CvStringHashNode,
        create_missing: ::std::os::raw::c_int,
    ) -> *mut CvFileNode;
}
extern "C" {
    pub fn cvGetFileNodeByName(
        fs: *const CvFileStorage,
        map: *const CvFileNode,
        name: *const ::std::os::raw::c_char,
    ) -> *mut CvFileNode;
}
extern "C" {
    pub fn cvRead(
        fs: *mut CvFileStorage,
        node: *mut CvFileNode,
        attributes: *mut CvAttrList,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvStartReadRawData(
        fs: *const CvFileStorage,
        src: *const CvFileNode,
        reader: *mut CvSeqReader,
    );
}
extern "C" {
    pub fn cvReadRawDataSlice(
        fs: *const CvFileStorage,
        reader: *mut CvSeqReader,
        count: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_void,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cvReadRawData(
        fs: *const CvFileStorage,
        src: *const CvFileNode,
        dst: *mut ::std::os::raw::c_void,
        dt: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn cvWriteFileNode(
        fs: *mut CvFileStorage,
        new_node_name: *const ::std::os::raw::c_char,
        node: *const CvFileNode,
        embed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvGetFileNodeName(
        node: *const CvFileNode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cvRegisterType(info: *const CvTypeInfo);
}
extern "C" {
    pub fn cvUnregisterType(type_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn cvFirstType() -> *mut CvTypeInfo;
}
extern "C" {
    pub fn cvFindType(
        type_name: *const ::std::os::raw::c_char,
    ) -> *mut CvTypeInfo;
}
extern "C" {
    pub fn cvTypeOf(
        struct_ptr: *const ::std::os::raw::c_void,
    ) -> *mut CvTypeInfo;
}
extern "C" {
    pub fn cvRelease(struct_ptr: *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cvClone(
        struct_ptr: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvSave(
        filename: *const ::std::os::raw::c_char,
        struct_ptr: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        comment: *const ::std::os::raw::c_char,
        attributes: CvAttrList,
    );
}
extern "C" {
    pub fn cvLoad(
        filename: *const ::std::os::raw::c_char,
        memstorage: *mut CvMemStorage,
        name: *const ::std::os::raw::c_char,
        real_name: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cvGetTickCount() -> int64;
}
extern "C" {
    pub fn cvGetTickFrequency() -> f64;
}
extern "C" {
    pub fn cvCheckHardwareSupport(
        feature: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGetNumThreads() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetNumThreads(threads: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvGetThreadNum() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGetErrStatus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetErrStatus(status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cvGetErrMode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvSetErrMode(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvError(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cvErrorStr(
        status: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn cvGetErrInfo(
        errcode_desc: *mut *const ::std::os::raw::c_char,
        description: *mut *const ::std::os::raw::c_char,
        filename: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvErrorFromIppStatus(
        ipp_status: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type CvErrorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn cvRedirectError(
        error_handler: CvErrorCallback,
        userdata: *mut ::std::os::raw::c_void,
        prev_userdata: *mut *mut ::std::os::raw::c_void,
    ) -> CvErrorCallback;
}
extern "C" {
    pub fn cvNulDevReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvStdErrReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cvGuiBoxReport(
        status: ::std::os::raw::c_int,
        func_name: *const ::std::os::raw::c_char,
        err_msg: *const ::std::os::raw::c_char,
        file_name: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvConnectedComp {
    pub area: f64,
    pub value: CvScalar,
    pub rect: CvRect,
    pub contour: *mut CvSeq,
}
#[test]
fn bindgen_test_layout_CvConnectedComp() {
    assert_eq!(
        ::std::mem::size_of::<CvConnectedComp>(),
        64usize,
        concat!("Size of: ", stringify!(CvConnectedComp))
    );
    assert_eq!(
        ::std::mem::align_of::<CvConnectedComp>(),
        8usize,
        concat!("Alignment of ", stringify!(CvConnectedComp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConnectedComp>())).area as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConnectedComp),
            "::",
            stringify!(area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConnectedComp>())).value as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConnectedComp),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConnectedComp>())).rect as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConnectedComp),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConnectedComp>())).contour as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConnectedComp),
            "::",
            stringify!(contour)
        )
    );
}
pub const SmoothMethod_c_CV_BLUR_NO_SCALE: SmoothMethod_c = 0;
pub const SmoothMethod_c_CV_BLUR: SmoothMethod_c = 1;
pub const SmoothMethod_c_CV_GAUSSIAN: SmoothMethod_c = 2;
pub const SmoothMethod_c_CV_MEDIAN: SmoothMethod_c = 3;
pub const SmoothMethod_c_CV_BILATERAL: SmoothMethod_c = 4;
pub type SmoothMethod_c = u32;
pub const CV_GAUSSIAN_5x5: _bindgen_ty_2 = 7;
pub type _bindgen_ty_2 = u32;
pub const CV_SCHARR: _bindgen_ty_3 = -1;
pub const CV_MAX_SOBEL_KSIZE: _bindgen_ty_3 = 7;
pub type _bindgen_ty_3 = i32;
pub const CV_BGR2BGRA: _bindgen_ty_4 = 0;
pub const CV_RGB2RGBA: _bindgen_ty_4 = 0;
pub const CV_BGRA2BGR: _bindgen_ty_4 = 1;
pub const CV_RGBA2RGB: _bindgen_ty_4 = 1;
pub const CV_BGR2RGBA: _bindgen_ty_4 = 2;
pub const CV_RGB2BGRA: _bindgen_ty_4 = 2;
pub const CV_RGBA2BGR: _bindgen_ty_4 = 3;
pub const CV_BGRA2RGB: _bindgen_ty_4 = 3;
pub const CV_BGR2RGB: _bindgen_ty_4 = 4;
pub const CV_RGB2BGR: _bindgen_ty_4 = 4;
pub const CV_BGRA2RGBA: _bindgen_ty_4 = 5;
pub const CV_RGBA2BGRA: _bindgen_ty_4 = 5;
pub const CV_BGR2GRAY: _bindgen_ty_4 = 6;
pub const CV_RGB2GRAY: _bindgen_ty_4 = 7;
pub const CV_GRAY2BGR: _bindgen_ty_4 = 8;
pub const CV_GRAY2RGB: _bindgen_ty_4 = 8;
pub const CV_GRAY2BGRA: _bindgen_ty_4 = 9;
pub const CV_GRAY2RGBA: _bindgen_ty_4 = 9;
pub const CV_BGRA2GRAY: _bindgen_ty_4 = 10;
pub const CV_RGBA2GRAY: _bindgen_ty_4 = 11;
pub const CV_BGR2BGR565: _bindgen_ty_4 = 12;
pub const CV_RGB2BGR565: _bindgen_ty_4 = 13;
pub const CV_BGR5652BGR: _bindgen_ty_4 = 14;
pub const CV_BGR5652RGB: _bindgen_ty_4 = 15;
pub const CV_BGRA2BGR565: _bindgen_ty_4 = 16;
pub const CV_RGBA2BGR565: _bindgen_ty_4 = 17;
pub const CV_BGR5652BGRA: _bindgen_ty_4 = 18;
pub const CV_BGR5652RGBA: _bindgen_ty_4 = 19;
pub const CV_GRAY2BGR565: _bindgen_ty_4 = 20;
pub const CV_BGR5652GRAY: _bindgen_ty_4 = 21;
pub const CV_BGR2BGR555: _bindgen_ty_4 = 22;
pub const CV_RGB2BGR555: _bindgen_ty_4 = 23;
pub const CV_BGR5552BGR: _bindgen_ty_4 = 24;
pub const CV_BGR5552RGB: _bindgen_ty_4 = 25;
pub const CV_BGRA2BGR555: _bindgen_ty_4 = 26;
pub const CV_RGBA2BGR555: _bindgen_ty_4 = 27;
pub const CV_BGR5552BGRA: _bindgen_ty_4 = 28;
pub const CV_BGR5552RGBA: _bindgen_ty_4 = 29;
pub const CV_GRAY2BGR555: _bindgen_ty_4 = 30;
pub const CV_BGR5552GRAY: _bindgen_ty_4 = 31;
pub const CV_BGR2XYZ: _bindgen_ty_4 = 32;
pub const CV_RGB2XYZ: _bindgen_ty_4 = 33;
pub const CV_XYZ2BGR: _bindgen_ty_4 = 34;
pub const CV_XYZ2RGB: _bindgen_ty_4 = 35;
pub const CV_BGR2YCrCb: _bindgen_ty_4 = 36;
pub const CV_RGB2YCrCb: _bindgen_ty_4 = 37;
pub const CV_YCrCb2BGR: _bindgen_ty_4 = 38;
pub const CV_YCrCb2RGB: _bindgen_ty_4 = 39;
pub const CV_BGR2HSV: _bindgen_ty_4 = 40;
pub const CV_RGB2HSV: _bindgen_ty_4 = 41;
pub const CV_BGR2Lab: _bindgen_ty_4 = 44;
pub const CV_RGB2Lab: _bindgen_ty_4 = 45;
pub const CV_BayerBG2BGR: _bindgen_ty_4 = 46;
pub const CV_BayerGB2BGR: _bindgen_ty_4 = 47;
pub const CV_BayerRG2BGR: _bindgen_ty_4 = 48;
pub const CV_BayerGR2BGR: _bindgen_ty_4 = 49;
pub const CV_BayerBG2RGB: _bindgen_ty_4 = 48;
pub const CV_BayerGB2RGB: _bindgen_ty_4 = 49;
pub const CV_BayerRG2RGB: _bindgen_ty_4 = 46;
pub const CV_BayerGR2RGB: _bindgen_ty_4 = 47;
pub const CV_BGR2Luv: _bindgen_ty_4 = 50;
pub const CV_RGB2Luv: _bindgen_ty_4 = 51;
pub const CV_BGR2HLS: _bindgen_ty_4 = 52;
pub const CV_RGB2HLS: _bindgen_ty_4 = 53;
pub const CV_HSV2BGR: _bindgen_ty_4 = 54;
pub const CV_HSV2RGB: _bindgen_ty_4 = 55;
pub const CV_Lab2BGR: _bindgen_ty_4 = 56;
pub const CV_Lab2RGB: _bindgen_ty_4 = 57;
pub const CV_Luv2BGR: _bindgen_ty_4 = 58;
pub const CV_Luv2RGB: _bindgen_ty_4 = 59;
pub const CV_HLS2BGR: _bindgen_ty_4 = 60;
pub const CV_HLS2RGB: _bindgen_ty_4 = 61;
pub const CV_BayerBG2BGR_VNG: _bindgen_ty_4 = 62;
pub const CV_BayerGB2BGR_VNG: _bindgen_ty_4 = 63;
pub const CV_BayerRG2BGR_VNG: _bindgen_ty_4 = 64;
pub const CV_BayerGR2BGR_VNG: _bindgen_ty_4 = 65;
pub const CV_BayerBG2RGB_VNG: _bindgen_ty_4 = 64;
pub const CV_BayerGB2RGB_VNG: _bindgen_ty_4 = 65;
pub const CV_BayerRG2RGB_VNG: _bindgen_ty_4 = 62;
pub const CV_BayerGR2RGB_VNG: _bindgen_ty_4 = 63;
pub const CV_BGR2HSV_FULL: _bindgen_ty_4 = 66;
pub const CV_RGB2HSV_FULL: _bindgen_ty_4 = 67;
pub const CV_BGR2HLS_FULL: _bindgen_ty_4 = 68;
pub const CV_RGB2HLS_FULL: _bindgen_ty_4 = 69;
pub const CV_HSV2BGR_FULL: _bindgen_ty_4 = 70;
pub const CV_HSV2RGB_FULL: _bindgen_ty_4 = 71;
pub const CV_HLS2BGR_FULL: _bindgen_ty_4 = 72;
pub const CV_HLS2RGB_FULL: _bindgen_ty_4 = 73;
pub const CV_LBGR2Lab: _bindgen_ty_4 = 74;
pub const CV_LRGB2Lab: _bindgen_ty_4 = 75;
pub const CV_LBGR2Luv: _bindgen_ty_4 = 76;
pub const CV_LRGB2Luv: _bindgen_ty_4 = 77;
pub const CV_Lab2LBGR: _bindgen_ty_4 = 78;
pub const CV_Lab2LRGB: _bindgen_ty_4 = 79;
pub const CV_Luv2LBGR: _bindgen_ty_4 = 80;
pub const CV_Luv2LRGB: _bindgen_ty_4 = 81;
pub const CV_BGR2YUV: _bindgen_ty_4 = 82;
pub const CV_RGB2YUV: _bindgen_ty_4 = 83;
pub const CV_YUV2BGR: _bindgen_ty_4 = 84;
pub const CV_YUV2RGB: _bindgen_ty_4 = 85;
pub const CV_BayerBG2GRAY: _bindgen_ty_4 = 86;
pub const CV_BayerGB2GRAY: _bindgen_ty_4 = 87;
pub const CV_BayerRG2GRAY: _bindgen_ty_4 = 88;
pub const CV_BayerGR2GRAY: _bindgen_ty_4 = 89;
pub const CV_YUV2RGB_NV12: _bindgen_ty_4 = 90;
pub const CV_YUV2BGR_NV12: _bindgen_ty_4 = 91;
pub const CV_YUV2RGB_NV21: _bindgen_ty_4 = 92;
pub const CV_YUV2BGR_NV21: _bindgen_ty_4 = 93;
pub const CV_YUV420sp2RGB: _bindgen_ty_4 = 92;
pub const CV_YUV420sp2BGR: _bindgen_ty_4 = 93;
pub const CV_YUV2RGBA_NV12: _bindgen_ty_4 = 94;
pub const CV_YUV2BGRA_NV12: _bindgen_ty_4 = 95;
pub const CV_YUV2RGBA_NV21: _bindgen_ty_4 = 96;
pub const CV_YUV2BGRA_NV21: _bindgen_ty_4 = 97;
pub const CV_YUV420sp2RGBA: _bindgen_ty_4 = 96;
pub const CV_YUV420sp2BGRA: _bindgen_ty_4 = 97;
pub const CV_YUV2RGB_YV12: _bindgen_ty_4 = 98;
pub const CV_YUV2BGR_YV12: _bindgen_ty_4 = 99;
pub const CV_YUV2RGB_IYUV: _bindgen_ty_4 = 100;
pub const CV_YUV2BGR_IYUV: _bindgen_ty_4 = 101;
pub const CV_YUV2RGB_I420: _bindgen_ty_4 = 100;
pub const CV_YUV2BGR_I420: _bindgen_ty_4 = 101;
pub const CV_YUV420p2RGB: _bindgen_ty_4 = 98;
pub const CV_YUV420p2BGR: _bindgen_ty_4 = 99;
pub const CV_YUV2RGBA_YV12: _bindgen_ty_4 = 102;
pub const CV_YUV2BGRA_YV12: _bindgen_ty_4 = 103;
pub const CV_YUV2RGBA_IYUV: _bindgen_ty_4 = 104;
pub const CV_YUV2BGRA_IYUV: _bindgen_ty_4 = 105;
pub const CV_YUV2RGBA_I420: _bindgen_ty_4 = 104;
pub const CV_YUV2BGRA_I420: _bindgen_ty_4 = 105;
pub const CV_YUV420p2RGBA: _bindgen_ty_4 = 102;
pub const CV_YUV420p2BGRA: _bindgen_ty_4 = 103;
pub const CV_YUV2GRAY_420: _bindgen_ty_4 = 106;
pub const CV_YUV2GRAY_NV21: _bindgen_ty_4 = 106;
pub const CV_YUV2GRAY_NV12: _bindgen_ty_4 = 106;
pub const CV_YUV2GRAY_YV12: _bindgen_ty_4 = 106;
pub const CV_YUV2GRAY_IYUV: _bindgen_ty_4 = 106;
pub const CV_YUV2GRAY_I420: _bindgen_ty_4 = 106;
pub const CV_YUV420sp2GRAY: _bindgen_ty_4 = 106;
pub const CV_YUV420p2GRAY: _bindgen_ty_4 = 106;
pub const CV_YUV2RGB_UYVY: _bindgen_ty_4 = 107;
pub const CV_YUV2BGR_UYVY: _bindgen_ty_4 = 108;
pub const CV_YUV2RGB_Y422: _bindgen_ty_4 = 107;
pub const CV_YUV2BGR_Y422: _bindgen_ty_4 = 108;
pub const CV_YUV2RGB_UYNV: _bindgen_ty_4 = 107;
pub const CV_YUV2BGR_UYNV: _bindgen_ty_4 = 108;
pub const CV_YUV2RGBA_UYVY: _bindgen_ty_4 = 111;
pub const CV_YUV2BGRA_UYVY: _bindgen_ty_4 = 112;
pub const CV_YUV2RGBA_Y422: _bindgen_ty_4 = 111;
pub const CV_YUV2BGRA_Y422: _bindgen_ty_4 = 112;
pub const CV_YUV2RGBA_UYNV: _bindgen_ty_4 = 111;
pub const CV_YUV2BGRA_UYNV: _bindgen_ty_4 = 112;
pub const CV_YUV2RGB_YUY2: _bindgen_ty_4 = 115;
pub const CV_YUV2BGR_YUY2: _bindgen_ty_4 = 116;
pub const CV_YUV2RGB_YVYU: _bindgen_ty_4 = 117;
pub const CV_YUV2BGR_YVYU: _bindgen_ty_4 = 118;
pub const CV_YUV2RGB_YUYV: _bindgen_ty_4 = 115;
pub const CV_YUV2BGR_YUYV: _bindgen_ty_4 = 116;
pub const CV_YUV2RGB_YUNV: _bindgen_ty_4 = 115;
pub const CV_YUV2BGR_YUNV: _bindgen_ty_4 = 116;
pub const CV_YUV2RGBA_YUY2: _bindgen_ty_4 = 119;
pub const CV_YUV2BGRA_YUY2: _bindgen_ty_4 = 120;
pub const CV_YUV2RGBA_YVYU: _bindgen_ty_4 = 121;
pub const CV_YUV2BGRA_YVYU: _bindgen_ty_4 = 122;
pub const CV_YUV2RGBA_YUYV: _bindgen_ty_4 = 119;
pub const CV_YUV2BGRA_YUYV: _bindgen_ty_4 = 120;
pub const CV_YUV2RGBA_YUNV: _bindgen_ty_4 = 119;
pub const CV_YUV2BGRA_YUNV: _bindgen_ty_4 = 120;
pub const CV_YUV2GRAY_UYVY: _bindgen_ty_4 = 123;
pub const CV_YUV2GRAY_YUY2: _bindgen_ty_4 = 124;
pub const CV_YUV2GRAY_Y422: _bindgen_ty_4 = 123;
pub const CV_YUV2GRAY_UYNV: _bindgen_ty_4 = 123;
pub const CV_YUV2GRAY_YVYU: _bindgen_ty_4 = 124;
pub const CV_YUV2GRAY_YUYV: _bindgen_ty_4 = 124;
pub const CV_YUV2GRAY_YUNV: _bindgen_ty_4 = 124;
pub const CV_RGBA2mRGBA: _bindgen_ty_4 = 125;
pub const CV_mRGBA2RGBA: _bindgen_ty_4 = 126;
pub const CV_RGB2YUV_I420: _bindgen_ty_4 = 127;
pub const CV_BGR2YUV_I420: _bindgen_ty_4 = 128;
pub const CV_RGB2YUV_IYUV: _bindgen_ty_4 = 127;
pub const CV_BGR2YUV_IYUV: _bindgen_ty_4 = 128;
pub const CV_RGBA2YUV_I420: _bindgen_ty_4 = 129;
pub const CV_BGRA2YUV_I420: _bindgen_ty_4 = 130;
pub const CV_RGBA2YUV_IYUV: _bindgen_ty_4 = 129;
pub const CV_BGRA2YUV_IYUV: _bindgen_ty_4 = 130;
pub const CV_RGB2YUV_YV12: _bindgen_ty_4 = 131;
pub const CV_BGR2YUV_YV12: _bindgen_ty_4 = 132;
pub const CV_RGBA2YUV_YV12: _bindgen_ty_4 = 133;
pub const CV_BGRA2YUV_YV12: _bindgen_ty_4 = 134;
pub const CV_BayerBG2BGR_EA: _bindgen_ty_4 = 135;
pub const CV_BayerGB2BGR_EA: _bindgen_ty_4 = 136;
pub const CV_BayerRG2BGR_EA: _bindgen_ty_4 = 137;
pub const CV_BayerGR2BGR_EA: _bindgen_ty_4 = 138;
pub const CV_BayerBG2RGB_EA: _bindgen_ty_4 = 137;
pub const CV_BayerGB2RGB_EA: _bindgen_ty_4 = 138;
pub const CV_BayerRG2RGB_EA: _bindgen_ty_4 = 135;
pub const CV_BayerGR2RGB_EA: _bindgen_ty_4 = 136;
pub const CV_BayerBG2BGRA: _bindgen_ty_4 = 139;
pub const CV_BayerGB2BGRA: _bindgen_ty_4 = 140;
pub const CV_BayerRG2BGRA: _bindgen_ty_4 = 141;
pub const CV_BayerGR2BGRA: _bindgen_ty_4 = 142;
pub const CV_BayerBG2RGBA: _bindgen_ty_4 = 141;
pub const CV_BayerGB2RGBA: _bindgen_ty_4 = 142;
pub const CV_BayerRG2RGBA: _bindgen_ty_4 = 139;
pub const CV_BayerGR2RGBA: _bindgen_ty_4 = 140;
pub const CV_COLORCVT_MAX: _bindgen_ty_4 = 143;
pub type _bindgen_ty_4 = u32;
pub const CV_INTER_NN: _bindgen_ty_5 = 0;
pub const CV_INTER_LINEAR: _bindgen_ty_5 = 1;
pub const CV_INTER_CUBIC: _bindgen_ty_5 = 2;
pub const CV_INTER_AREA: _bindgen_ty_5 = 3;
pub const CV_INTER_LANCZOS4: _bindgen_ty_5 = 4;
pub type _bindgen_ty_5 = u32;
pub const CV_WARP_FILL_OUTLIERS: _bindgen_ty_6 = 8;
pub const CV_WARP_INVERSE_MAP: _bindgen_ty_6 = 16;
pub type _bindgen_ty_6 = u32;
pub const MorphShapes_c_CV_SHAPE_RECT: MorphShapes_c = 0;
pub const MorphShapes_c_CV_SHAPE_CROSS: MorphShapes_c = 1;
pub const MorphShapes_c_CV_SHAPE_ELLIPSE: MorphShapes_c = 2;
pub const MorphShapes_c_CV_SHAPE_CUSTOM: MorphShapes_c = 100;
pub type MorphShapes_c = u32;
pub const CV_MOP_ERODE: _bindgen_ty_7 = 0;
pub const CV_MOP_DILATE: _bindgen_ty_7 = 1;
pub const CV_MOP_OPEN: _bindgen_ty_7 = 2;
pub const CV_MOP_CLOSE: _bindgen_ty_7 = 3;
pub const CV_MOP_GRADIENT: _bindgen_ty_7 = 4;
pub const CV_MOP_TOPHAT: _bindgen_ty_7 = 5;
pub const CV_MOP_BLACKHAT: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvMoments {
    pub m00: f64,
    pub m10: f64,
    pub m01: f64,
    pub m20: f64,
    pub m11: f64,
    pub m02: f64,
    pub m30: f64,
    pub m21: f64,
    pub m12: f64,
    pub m03: f64,
    pub mu20: f64,
    pub mu11: f64,
    pub mu02: f64,
    pub mu30: f64,
    pub mu21: f64,
    pub mu12: f64,
    pub mu03: f64,
    pub inv_sqrt_m00: f64,
}
#[test]
fn bindgen_test_layout_CvMoments() {
    assert_eq!(
        ::std::mem::size_of::<CvMoments>(),
        144usize,
        concat!("Size of: ", stringify!(CvMoments))
    );
    assert_eq!(
        ::std::mem::align_of::<CvMoments>(),
        8usize,
        concat!("Alignment of ", stringify!(CvMoments))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m00 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m00)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m10 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m01 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m01)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m20 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m11 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m02 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m02)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m30 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m21 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m12 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).m03 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(m03)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu20 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu02 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu02)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu30 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu21 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu12 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).mu03 as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(mu03)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvMoments>())).inv_sqrt_m00 as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CvMoments),
            "::",
            stringify!(inv_sqrt_m00)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvHuMoments {
    pub hu1: f64,
    pub hu2: f64,
    pub hu3: f64,
    pub hu4: f64,
    pub hu5: f64,
    pub hu6: f64,
    pub hu7: f64,
}
#[test]
fn bindgen_test_layout_CvHuMoments() {
    assert_eq!(
        ::std::mem::size_of::<CvHuMoments>(),
        56usize,
        concat!("Size of: ", stringify!(CvHuMoments))
    );
    assert_eq!(
        ::std::mem::align_of::<CvHuMoments>(),
        8usize,
        concat!("Alignment of ", stringify!(CvHuMoments))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu3 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu4 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu5 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu6 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvHuMoments>())).hu7 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvHuMoments),
            "::",
            stringify!(hu7)
        )
    );
}
pub const CV_TM_SQDIFF: _bindgen_ty_8 = 0;
pub const CV_TM_SQDIFF_NORMED: _bindgen_ty_8 = 1;
pub const CV_TM_CCORR: _bindgen_ty_8 = 2;
pub const CV_TM_CCORR_NORMED: _bindgen_ty_8 = 3;
pub const CV_TM_CCOEFF: _bindgen_ty_8 = 4;
pub const CV_TM_CCOEFF_NORMED: _bindgen_ty_8 = 5;
pub type _bindgen_ty_8 = u32;
pub type CvDistanceFunction = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const f32,
        b: *const f32,
        user_param: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
pub const CV_RETR_EXTERNAL: _bindgen_ty_9 = 0;
pub const CV_RETR_LIST: _bindgen_ty_9 = 1;
pub const CV_RETR_CCOMP: _bindgen_ty_9 = 2;
pub const CV_RETR_TREE: _bindgen_ty_9 = 3;
pub const CV_RETR_FLOODFILL: _bindgen_ty_9 = 4;
pub type _bindgen_ty_9 = u32;
pub const CV_CHAIN_CODE: _bindgen_ty_10 = 0;
pub const CV_CHAIN_APPROX_NONE: _bindgen_ty_10 = 1;
pub const CV_CHAIN_APPROX_SIMPLE: _bindgen_ty_10 = 2;
pub const CV_CHAIN_APPROX_TC89_L1: _bindgen_ty_10 = 3;
pub const CV_CHAIN_APPROX_TC89_KCOS: _bindgen_ty_10 = 4;
pub const CV_LINK_RUNS: _bindgen_ty_10 = 5;
pub type _bindgen_ty_10 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CvContourScanner {
    _unused: [u8; 0],
}
pub type CvContourScanner = *mut _CvContourScanner;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvChainPtReader {
    pub header_size: ::std::os::raw::c_int,
    pub seq: *mut CvSeq,
    pub block: *mut CvSeqBlock,
    pub ptr: *mut schar,
    pub block_min: *mut schar,
    pub block_max: *mut schar,
    pub delta_index: ::std::os::raw::c_int,
    pub prev_elem: *mut schar,
    pub code: ::std::os::raw::c_char,
    pub pt: CvPoint,
    pub deltas: [[schar; 2usize]; 8usize],
}
#[test]
fn bindgen_test_layout_CvChainPtReader() {
    assert_eq!(
        ::std::mem::size_of::<CvChainPtReader>(),
        96usize,
        concat!("Size of: ", stringify!(CvChainPtReader))
    );
    assert_eq!(
        ::std::mem::align_of::<CvChainPtReader>(),
        8usize,
        concat!("Alignment of ", stringify!(CvChainPtReader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).header_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).seq as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).block as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).block_min as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(block_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).block_max as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).delta_index as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(delta_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).prev_elem as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(prev_elem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).code as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).pt as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(pt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvChainPtReader>())).deltas as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CvChainPtReader),
            "::",
            stringify!(deltas)
        )
    );
}
pub const CV_POLY_APPROX_DP: _bindgen_ty_11 = 0;
pub type _bindgen_ty_11 = u32;
pub const CV_CONTOURS_MATCH_I1: _bindgen_ty_12 = 1;
pub const CV_CONTOURS_MATCH_I2: _bindgen_ty_12 = 2;
pub const CV_CONTOURS_MATCH_I3: _bindgen_ty_12 = 3;
pub type _bindgen_ty_12 = u32;
pub const CV_CLOCKWISE: _bindgen_ty_13 = 1;
pub const CV_COUNTER_CLOCKWISE: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvConvexityDefect {
    pub start: *mut CvPoint,
    pub end: *mut CvPoint,
    pub depth_point: *mut CvPoint,
    pub depth: f32,
}
#[test]
fn bindgen_test_layout_CvConvexityDefect() {
    assert_eq!(
        ::std::mem::size_of::<CvConvexityDefect>(),
        32usize,
        concat!("Size of: ", stringify!(CvConvexityDefect))
    );
    assert_eq!(
        ::std::mem::align_of::<CvConvexityDefect>(),
        8usize,
        concat!("Alignment of ", stringify!(CvConvexityDefect))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConvexityDefect>())).start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConvexityDefect),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConvexityDefect>())).end as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConvexityDefect),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConvexityDefect>())).depth_point
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConvexityDefect),
            "::",
            stringify!(depth_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvConvexityDefect>())).depth as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CvConvexityDefect),
            "::",
            stringify!(depth)
        )
    );
}
pub const CV_COMP_CORREL: _bindgen_ty_14 = 0;
pub const CV_COMP_CHISQR: _bindgen_ty_14 = 1;
pub const CV_COMP_INTERSECT: _bindgen_ty_14 = 2;
pub const CV_COMP_BHATTACHARYYA: _bindgen_ty_14 = 3;
pub const CV_COMP_HELLINGER: _bindgen_ty_14 = 3;
pub const CV_COMP_CHISQR_ALT: _bindgen_ty_14 = 4;
pub const CV_COMP_KL_DIV: _bindgen_ty_14 = 5;
pub type _bindgen_ty_14 = u32;
pub const CV_DIST_MASK_3: _bindgen_ty_15 = 3;
pub const CV_DIST_MASK_5: _bindgen_ty_15 = 5;
pub const CV_DIST_MASK_PRECISE: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = u32;
pub const CV_DIST_LABEL_CCOMP: _bindgen_ty_16 = 0;
pub const CV_DIST_LABEL_PIXEL: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = u32;
pub const CV_DIST_USER: _bindgen_ty_17 = -1;
pub const CV_DIST_L1: _bindgen_ty_17 = 1;
pub const CV_DIST_L2: _bindgen_ty_17 = 2;
pub const CV_DIST_C: _bindgen_ty_17 = 3;
pub const CV_DIST_L12: _bindgen_ty_17 = 4;
pub const CV_DIST_FAIR: _bindgen_ty_17 = 5;
pub const CV_DIST_WELSCH: _bindgen_ty_17 = 6;
pub const CV_DIST_HUBER: _bindgen_ty_17 = 7;
pub type _bindgen_ty_17 = i32;
pub const CV_THRESH_BINARY: _bindgen_ty_18 = 0;
pub const CV_THRESH_BINARY_INV: _bindgen_ty_18 = 1;
pub const CV_THRESH_TRUNC: _bindgen_ty_18 = 2;
pub const CV_THRESH_TOZERO: _bindgen_ty_18 = 3;
pub const CV_THRESH_TOZERO_INV: _bindgen_ty_18 = 4;
pub const CV_THRESH_MASK: _bindgen_ty_18 = 7;
pub const CV_THRESH_OTSU: _bindgen_ty_18 = 8;
pub const CV_THRESH_TRIANGLE: _bindgen_ty_18 = 16;
pub type _bindgen_ty_18 = u32;
pub const CV_ADAPTIVE_THRESH_MEAN_C: _bindgen_ty_19 = 0;
pub const CV_ADAPTIVE_THRESH_GAUSSIAN_C: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = u32;
pub const CV_FLOODFILL_FIXED_RANGE: _bindgen_ty_20 = 65536;
pub const CV_FLOODFILL_MASK_ONLY: _bindgen_ty_20 = 131072;
pub type _bindgen_ty_20 = u32;
pub const CV_CANNY_L2_GRADIENT: _bindgen_ty_21 = -2147483648;
pub type _bindgen_ty_21 = i32;
pub const CV_HOUGH_STANDARD: _bindgen_ty_22 = 0;
pub const CV_HOUGH_PROBABILISTIC: _bindgen_ty_22 = 1;
pub const CV_HOUGH_MULTI_SCALE: _bindgen_ty_22 = 2;
pub const CV_HOUGH_GRADIENT: _bindgen_ty_22 = 3;
pub type _bindgen_ty_22 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvFeatureTree {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvLSH {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvLSHOperations {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Adds image to accumulator"]
    #[doc = "@see cv::accumulate"]
    pub fn cvAcc(image: *const CvArr, sum: *mut CvArr, mask: *const CvArr);
}
extern "C" {
    #[doc = " @brief Adds squared image to accumulator"]
    #[doc = "@see cv::accumulateSquare"]
    pub fn cvSquareAcc(
        image: *const CvArr,
        sqsum: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    #[doc = " @brief Adds a product of two images to accumulator"]
    #[doc = "@see cv::accumulateProduct"]
    pub fn cvMultiplyAcc(
        image1: *const CvArr,
        image2: *const CvArr,
        acc: *mut CvArr,
        mask: *const CvArr,
    );
}
extern "C" {
    #[doc = " @brief Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha"]
    #[doc = "@see cv::accumulateWeighted"]
    pub fn cvRunningAvg(
        image: *const CvArr,
        acc: *mut CvArr,
        alpha: f64,
        mask: *const CvArr,
    );
}
extern "C" {
    #[doc = " Copies source 2D array inside of the larger destination array and"]
    #[doc = "makes a border of the specified type (IPL_BORDER_*) around the copied area."]
    pub fn cvCopyMakeBorder(
        src: *const CvArr,
        dst: *mut CvArr,
        offset: CvPoint,
        bordertype: ::std::os::raw::c_int,
        value: CvScalar,
    );
}
extern "C" {
    #[doc = " @brief Smooths the image in one of several ways."]
    #[doc = ""]
    #[doc = "@param src The source image"]
    #[doc = "@param dst The destination image"]
    #[doc = "@param smoothtype Type of the smoothing, see SmoothMethod_c"]
    #[doc = "@param size1 The first parameter of the smoothing operation, the aperture width. Must be a"]
    #[doc = "positive odd number (1, 3, 5, ...)"]
    #[doc = "@param size2 The second parameter of the smoothing operation, the aperture height. Ignored by"]
    #[doc = "CV_MEDIAN and CV_BILATERAL methods. In the case of simple scaled/non-scaled and Gaussian blur if"]
    #[doc = "size2 is zero, it is set to size1. Otherwise it must be a positive odd number."]
    #[doc = "@param sigma1 In the case of a Gaussian parameter this parameter may specify Gaussian \\f$\\sigma\\f$"]
    #[doc = "(standard deviation). If it is zero, it is calculated from the kernel size:"]
    #[doc = "\\f[\\sigma  = 0.3 (n/2 - 1) + 0.8  \\quad   \\text{where}   \\quad  n= \\begin{array}{l l} \\mbox{\\texttt{size1} for horizontal kernel} \\\\ \\mbox{\\texttt{size2} for vertical kernel} \\end{array}\\f]"]
    #[doc = "Using standard sigma for small kernels ( \\f$3\\times 3\\f$ to \\f$7\\times 7\\f$ ) gives better speed. If"]
    #[doc = "sigma1 is not zero, while size1 and size2 are zeros, the kernel size is calculated from the"]
    #[doc = "sigma (to provide accurate enough operation)."]
    #[doc = "@param sigma2 additional parameter for bilateral filtering"]
    #[doc = ""]
    #[doc = "@see cv::GaussianBlur, cv::blur, cv::medianBlur, cv::bilateralFilter."]
    pub fn cvSmooth(
        src: *const CvArr,
        dst: *mut CvArr,
        smoothtype: ::std::os::raw::c_int,
        size1: ::std::os::raw::c_int,
        size2: ::std::os::raw::c_int,
        sigma1: f64,
        sigma2: f64,
    );
}
extern "C" {
    #[doc = " @brief Convolves an image with the kernel."]
    #[doc = ""]
    #[doc = "@param src input image."]
    #[doc = "@param dst output image of the same size and the same number of channels as src."]
    #[doc = "@param kernel convolution kernel (or rather a correlation kernel), a single-channel floating point"]
    #[doc = "matrix; if you want to apply different kernels to different channels, split the image into"]
    #[doc = "separate color planes using split and process them individually."]
    #[doc = "@param anchor anchor of the kernel that indicates the relative position of a filtered point within"]
    #[doc = "the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor"]
    #[doc = "is at the kernel center."]
    #[doc = ""]
    #[doc = "@see cv::filter2D"]
    pub fn cvFilter2D(
        src: *const CvArr,
        dst: *mut CvArr,
        kernel: *const CvMat,
        anchor: CvPoint,
    );
}
extern "C" {
    #[doc = " @brief Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)"]
    #[doc = "@see cv::integral"]
    pub fn cvIntegral(
        image: *const CvArr,
        sum: *mut CvArr,
        sqsum: *mut CvArr,
        tilted_sum: *mut CvArr,
    );
}
extern "C" {
    #[doc = " @brief Smoothes the input image with gaussian kernel and then down-samples it."]
    #[doc = ""]
    #[doc = "dst_width = floor(src_width/2)[+1],"]
    #[doc = "dst_height = floor(src_height/2)[+1]"]
    #[doc = "@see cv::pyrDown"]
    pub fn cvPyrDown(
        src: *const CvArr,
        dst: *mut CvArr,
        filter: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Up-samples image and smoothes the result with gaussian kernel."]
    #[doc = ""]
    #[doc = "dst_width = src_width*2,"]
    #[doc = "dst_height = src_height*2"]
    #[doc = "@see cv::pyrUp"]
    pub fn cvPyrUp(
        src: *const CvArr,
        dst: *mut CvArr,
        filter: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Builds pyramid for an image"]
    #[doc = "@see buildPyramid"]
    pub fn cvCreatePyramid(
        img: *const CvArr,
        extra_layers: ::std::os::raw::c_int,
        rate: f64,
        layer_sizes: *const CvSize,
        bufarr: *mut CvArr,
        calc: ::std::os::raw::c_int,
        filter: ::std::os::raw::c_int,
    ) -> *mut *mut CvMat;
}
extern "C" {
    #[doc = " @brief Releases pyramid"]
    pub fn cvReleasePyramid(
        pyramid: *mut *mut *mut CvMat,
        extra_layers: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Filters image using meanshift algorithm"]
    #[doc = "@see cv::pyrMeanShiftFiltering"]
    pub fn cvPyrMeanShiftFiltering(
        src: *const CvArr,
        dst: *mut CvArr,
        sp: f64,
        sr: f64,
        max_level: ::std::os::raw::c_int,
        termcrit: CvTermCriteria,
    );
}
extern "C" {
    #[doc = " @brief Segments image using seed \"markers\""]
    #[doc = "@see cv::watershed"]
    pub fn cvWatershed(image: *const CvArr, markers: *mut CvArr);
}
extern "C" {
    #[doc = " @brief Calculates an image derivative using generalized Sobel"]
    #[doc = ""]
    #[doc = "(aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator."]
    #[doc = "Scharr can be used only for the first dx or dy derivative"]
    #[doc = "@see cv::Sobel"]
    pub fn cvSobel(
        src: *const CvArr,
        dst: *mut CvArr,
        xorder: ::std::os::raw::c_int,
        yorder: ::std::os::raw::c_int,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates the image Laplacian: (d2/dx + d2/dy)I"]
    #[doc = "@see cv::Laplacian"]
    pub fn cvLaplace(
        src: *const CvArr,
        dst: *mut CvArr,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Converts input array pixels from one color space to another"]
    #[doc = "@see cv::cvtColor"]
    pub fn cvCvtColor(
        src: *const CvArr,
        dst: *mut CvArr,
        code: ::std::os::raw::c_int,
    );
}
#[link(name = "opencv_core")]
#[link(name = "opencv_imgproc")]
extern "C" {
    #[doc = " @brief Resizes image (input array is resized to fit the destination array)"]
    #[doc = "@see cv::resize"]
    pub fn cvResize(
        src: *const CvArr,
        dst: *mut CvArr,
        interpolation: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Warps image with affine transform"]
    #[doc = "@note ::cvGetQuadrangleSubPix is similar to ::cvWarpAffine, but the outliers are extrapolated using"]
    #[doc = "replication border mode."]
    #[doc = "@see cv::warpAffine"]
    pub fn cvWarpAffine(
        src: *const CvArr,
        dst: *mut CvArr,
        map_matrix: *const CvMat,
        flags: ::std::os::raw::c_int,
        fillval: CvScalar,
    );
}
extern "C" {
    #[doc = " @brief Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)"]
    #[doc = "@see cv::getAffineTransform"]
    pub fn cvGetAffineTransform(
        src: *const CvPoint2D32f,
        dst: *const CvPoint2D32f,
        map_matrix: *mut CvMat,
    ) -> *mut CvMat;
}
extern "C" {
    #[doc = " @brief Computes rotation_matrix matrix"]
    #[doc = "@see cv::getRotationMatrix2D"]
    pub fn cv2DRotationMatrix(
        center: CvPoint2D32f,
        angle: f64,
        scale: f64,
        map_matrix: *mut CvMat,
    ) -> *mut CvMat;
}
extern "C" {
    #[doc = " @brief Warps image with perspective (projective) transform"]
    #[doc = "@see cv::warpPerspective"]
    pub fn cvWarpPerspective(
        src: *const CvArr,
        dst: *mut CvArr,
        map_matrix: *const CvMat,
        flags: ::std::os::raw::c_int,
        fillval: CvScalar,
    );
}
extern "C" {
    #[doc = " @brief Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)"]
    #[doc = "@see cv::getPerspectiveTransform"]
    pub fn cvGetPerspectiveTransform(
        src: *const CvPoint2D32f,
        dst: *const CvPoint2D32f,
        map_matrix: *mut CvMat,
    ) -> *mut CvMat;
}
extern "C" {
    #[doc = " @brief Performs generic geometric transformation using the specified coordinate maps"]
    #[doc = "@see cv::remap"]
    pub fn cvRemap(
        src: *const CvArr,
        dst: *mut CvArr,
        mapx: *const CvArr,
        mapy: *const CvArr,
        flags: ::std::os::raw::c_int,
        fillval: CvScalar,
    );
}
extern "C" {
    #[doc = " @brief Converts mapx & mapy from floating-point to integer formats for cvRemap"]
    #[doc = "@see cv::convertMaps"]
    pub fn cvConvertMaps(
        mapx: *const CvArr,
        mapy: *const CvArr,
        mapxy: *mut CvArr,
        mapalpha: *mut CvArr,
    );
}
extern "C" {
    #[doc = " @brief Performs forward or inverse log-polar image transform"]
    #[doc = "@see cv::logPolar"]
    pub fn cvLogPolar(
        src: *const CvArr,
        dst: *mut CvArr,
        center: CvPoint2D32f,
        M: f64,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Performs forward or inverse linear-polar image transform"]
    #[doc = "@see cv::linearPolar"]
    pub fn cvLinearPolar(
        src: *const CvArr,
        dst: *mut CvArr,
        center: CvPoint2D32f,
        maxRadius: f64,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Transforms the input image to compensate lens distortion"]
    #[doc = "@see cv::undistort"]
    pub fn cvUndistort2(
        src: *const CvArr,
        dst: *mut CvArr,
        camera_matrix: *const CvMat,
        distortion_coeffs: *const CvMat,
        new_camera_matrix: *const CvMat,
    );
}
extern "C" {
    #[doc = " @brief Computes transformation map from intrinsic camera parameters"]
    #[doc = "that can used by cvRemap"]
    pub fn cvInitUndistortMap(
        camera_matrix: *const CvMat,
        distortion_coeffs: *const CvMat,
        mapx: *mut CvArr,
        mapy: *mut CvArr,
    );
}
extern "C" {
    #[doc = " @brief Computes undistortion+rectification map for a head of stereo camera"]
    #[doc = "@see cv::initUndistortRectifyMap"]
    pub fn cvInitUndistortRectifyMap(
        camera_matrix: *const CvMat,
        dist_coeffs: *const CvMat,
        R: *const CvMat,
        new_camera_matrix: *const CvMat,
        mapx: *mut CvArr,
        mapy: *mut CvArr,
    );
}
extern "C" {
    #[doc = " @brief Computes the original (undistorted) feature coordinates"]
    #[doc = "from the observed (distorted) coordinates"]
    #[doc = "@see cv::undistortPoints"]
    pub fn cvUndistortPoints(
        src: *const CvMat,
        dst: *mut CvMat,
        camera_matrix: *const CvMat,
        dist_coeffs: *const CvMat,
        R: *const CvMat,
        P: *const CvMat,
    );
}
extern "C" {
    #[doc = " @brief Returns a structuring element of the specified size and shape for morphological operations."]
    #[doc = ""]
    #[doc = "@note the created structuring element IplConvKernel\\* element must be released in the end using"]
    #[doc = "`cvReleaseStructuringElement(&element)`."]
    #[doc = ""]
    #[doc = "@param cols Width of the structuring element"]
    #[doc = "@param rows Height of the structuring element"]
    #[doc = "@param anchor_x x-coordinate of the anchor"]
    #[doc = "@param anchor_y y-coordinate of the anchor"]
    #[doc = "@param shape element shape that could be one of the cv::MorphShapes_c"]
    #[doc = "@param values integer array of cols*rows elements that specifies the custom shape of the"]
    #[doc = "structuring element, when shape=CV_SHAPE_CUSTOM."]
    #[doc = ""]
    #[doc = "@see cv::getStructuringElement"]
    pub fn cvCreateStructuringElementEx(
        cols: ::std::os::raw::c_int,
        rows: ::std::os::raw::c_int,
        anchor_x: ::std::os::raw::c_int,
        anchor_y: ::std::os::raw::c_int,
        shape: ::std::os::raw::c_int,
        values: *mut ::std::os::raw::c_int,
    ) -> *mut IplConvKernel;
}
extern "C" {
    #[doc = " @brief releases structuring element"]
    #[doc = "@see cvCreateStructuringElementEx"]
    pub fn cvReleaseStructuringElement(element: *mut *mut IplConvKernel);
}
extern "C" {
    #[doc = " @brief erodes input image (applies minimum filter) one or more times."]
    #[doc = "If element pointer is NULL, 3x3 rectangular element is used"]
    #[doc = "@see cv::erode"]
    pub fn cvErode(
        src: *const CvArr,
        dst: *mut CvArr,
        element: *mut IplConvKernel,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief dilates input image (applies maximum filter) one or more times."]
    #[doc = ""]
    #[doc = "If element pointer is NULL, 3x3 rectangular element is used"]
    #[doc = "@see cv::dilate"]
    pub fn cvDilate(
        src: *const CvArr,
        dst: *mut CvArr,
        element: *mut IplConvKernel,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Performs complex morphological transformation"]
    #[doc = "@see cv::morphologyEx"]
    pub fn cvMorphologyEx(
        src: *const CvArr,
        dst: *mut CvArr,
        temp: *mut CvArr,
        element: *mut IplConvKernel,
        operation: ::std::os::raw::c_int,
        iterations: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates all spatial and central moments up to the 3rd order"]
    #[doc = "@see cv::moments"]
    pub fn cvMoments(
        arr: *const CvArr,
        moments: *mut CvMoments,
        binary: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieve spatial moments"]
    pub fn cvGetSpatialMoment(
        moments: *mut CvMoments,
        x_order: ::std::os::raw::c_int,
        y_order: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Retrieve central moments"]
    pub fn cvGetCentralMoment(
        moments: *mut CvMoments,
        x_order: ::std::os::raw::c_int,
        y_order: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Retrieve normalized central moments"]
    pub fn cvGetNormalizedCentralMoment(
        moments: *mut CvMoments,
        x_order: ::std::os::raw::c_int,
        y_order: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Calculates 7 Hu\'s invariants from precalculated spatial and central moments"]
    #[doc = "@see cv::HuMoments"]
    pub fn cvGetHuMoments(
        moments: *mut CvMoments,
        hu_moments: *mut CvHuMoments,
    );
}
extern "C" {
    #[doc = " @brief Fetches pixels that belong to the specified line segment and stores them to the buffer."]
    #[doc = ""]
    #[doc = "Returns the number of retrieved points."]
    #[doc = "@see cv::LineSegmentDetector"]
    pub fn cvSampleLine(
        image: *const CvArr,
        pt1: CvPoint,
        pt2: CvPoint,
        buffer: *mut ::std::os::raw::c_void,
        connectivity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves the rectangular image region with specified center from the input array."]
    #[doc = ""]
    #[doc = "dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2)."]
    #[doc = "Values of pixels with fractional coordinates are retrieved using bilinear interpolation"]
    #[doc = "@see cv::getRectSubPix"]
    pub fn cvGetRectSubPix(
        src: *const CvArr,
        dst: *mut CvArr,
        center: CvPoint2D32f,
    );
}
extern "C" {
    #[doc = " @brief Retrieves quadrangle from the input array."]
    #[doc = ""]
    #[doc = "matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]\' + b)"]
    #[doc = "( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels"]
    #[doc = "with fractional coordinates)"]
    #[doc = "@see cvWarpAffine"]
    pub fn cvGetQuadrangleSubPix(
        src: *const CvArr,
        dst: *mut CvArr,
        map_matrix: *const CvMat,
    );
}
extern "C" {
    #[doc = " @brief Measures similarity between template and overlapped windows in the source image"]
    #[doc = "and fills the resultant image with the measurements"]
    #[doc = "@see cv::matchTemplate"]
    pub fn cvMatchTemplate(
        image: *const CvArr,
        templ: *const CvArr,
        result: *mut CvArr,
        method: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Computes earth mover distance between"]
    #[doc = "two weighted point sets (called signatures)"]
    #[doc = "@see cv::EMD"]
    pub fn cvCalcEMD2(
        signature1: *const CvArr,
        signature2: *const CvArr,
        distance_type: ::std::os::raw::c_int,
        distance_func: CvDistanceFunction,
        cost_matrix: *const CvArr,
        flow: *mut CvArr,
        lower_bound: *mut f32,
        userdata: *mut ::std::os::raw::c_void,
    ) -> f32;
}
extern "C" {
    #[doc = " @brief Retrieves outer and optionally inner boundaries of white (non-zero) connected"]
    #[doc = "components in the black (zero) background"]
    #[doc = "@see cv::findContours, cvStartFindContours, cvFindNextContour, cvSubstituteContour, cvEndFindContours"]
    pub fn cvFindContours(
        image: *mut CvArr,
        storage: *mut CvMemStorage,
        first_contour: *mut *mut CvSeq,
        header_size: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
        offset: CvPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initializes contour retrieving process."]
    #[doc = ""]
    #[doc = "Calls cvStartFindContours."]
    #[doc = "Calls cvFindNextContour until null pointer is returned"]
    #[doc = "or some other condition becomes true."]
    #[doc = "Calls cvEndFindContours at the end."]
    #[doc = "@see cvFindContours"]
    pub fn cvStartFindContours(
        image: *mut CvArr,
        storage: *mut CvMemStorage,
        header_size: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        method: ::std::os::raw::c_int,
        offset: CvPoint,
    ) -> CvContourScanner;
}
extern "C" {
    #[doc = " @brief Retrieves next contour"]
    #[doc = "@see cvFindContours"]
    pub fn cvFindNextContour(scanner: CvContourScanner) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Substitutes the last retrieved contour with the new one"]
    #[doc = ""]
    #[doc = "(if the substitutor is null, the last retrieved contour is removed from the tree)"]
    #[doc = "@see cvFindContours"]
    pub fn cvSubstituteContour(
        scanner: CvContourScanner,
        new_contour: *mut CvSeq,
    );
}
extern "C" {
    #[doc = " @brief Releases contour scanner and returns pointer to the first outer contour"]
    #[doc = "@see cvFindContours"]
    pub fn cvEndFindContours(scanner: *mut CvContourScanner) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Approximates Freeman chain(s) with a polygonal curve."]
    #[doc = ""]
    #[doc = "This is a standalone contour approximation routine, not represented in the new interface. When"]
    #[doc = "cvFindContours retrieves contours as Freeman chains, it calls the function to get approximated"]
    #[doc = "contours, represented as polygons."]
    #[doc = ""]
    #[doc = "@param src_seq Pointer to the approximated Freeman chain that can refer to other chains."]
    #[doc = "@param storage Storage location for the resulting polylines."]
    #[doc = "@param method Approximation method (see the description of the function :ocvFindContours )."]
    #[doc = "@param parameter Method parameter (not used now)."]
    #[doc = "@param minimal_perimeter Approximates only those contours whose perimeters are not less than"]
    #[doc = "minimal_perimeter . Other chains are removed from the resulting structure."]
    #[doc = "@param recursive Recursion flag. If it is non-zero, the function approximates all chains that can"]
    #[doc = "be obtained from chain by using the h_next or v_next links. Otherwise, the single input chain is"]
    #[doc = "approximated."]
    #[doc = "@see cvStartReadChainPoints, cvReadChainPoint"]
    pub fn cvApproxChains(
        src_seq: *mut CvSeq,
        storage: *mut CvMemStorage,
        method: ::std::os::raw::c_int,
        parameter: f64,
        minimal_perimeter: ::std::os::raw::c_int,
        recursive: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Initializes Freeman chain reader."]
    #[doc = ""]
    #[doc = "The reader is used to iteratively get coordinates of all the chain points."]
    #[doc = "If the Freeman codes should be read as is, a simple sequence reader should be used"]
    #[doc = "@see cvApproxChains"]
    pub fn cvStartReadChainPoints(
        chain: *mut CvChain,
        reader: *mut CvChainPtReader,
    );
}
extern "C" {
    #[doc = " @brief Retrieves the next chain point"]
    #[doc = "@see cvApproxChains"]
    pub fn cvReadChainPoint(reader: *mut CvChainPtReader) -> CvPoint;
}
extern "C" {
    #[doc = " @brief Approximates a single polygonal curve (contour) or"]
    #[doc = "a tree of polygonal curves (contours)"]
    #[doc = "@see cv::approxPolyDP"]
    pub fn cvApproxPoly(
        src_seq: *const ::std::os::raw::c_void,
        header_size: ::std::os::raw::c_int,
        storage: *mut CvMemStorage,
        method: ::std::os::raw::c_int,
        eps: f64,
        recursive: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Calculates perimeter of a contour or length of a part of contour"]
    #[doc = "@see cv::arcLength"]
    pub fn cvArcLength(
        curve: *const ::std::os::raw::c_void,
        slice: CvSlice,
        is_closed: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Calculates contour bounding rectangle (update=1) or"]
    #[doc = "just retrieves pre-calculated rectangle (update=0)"]
    #[doc = "@see cv::boundingRect"]
    pub fn cvBoundingRect(
        points: *mut CvArr,
        update: ::std::os::raw::c_int,
    ) -> CvRect;
}
extern "C" {
    #[doc = " @brief Calculates area of a contour or contour segment"]
    #[doc = "@see cv::contourArea"]
    pub fn cvContourArea(
        contour: *const CvArr,
        slice: CvSlice,
        oriented: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Finds minimum area rotated rectangle bounding a set of points"]
    #[doc = "@see cv::minAreaRect"]
    pub fn cvMinAreaRect2(
        points: *const CvArr,
        storage: *mut CvMemStorage,
    ) -> CvBox2D;
}
extern "C" {
    #[doc = " @brief Finds minimum enclosing circle for a set of points"]
    #[doc = "@see cv::minEnclosingCircle"]
    pub fn cvMinEnclosingCircle(
        points: *const CvArr,
        center: *mut CvPoint2D32f,
        radius: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compares two contours by matching their moments"]
    #[doc = "@see cv::matchShapes"]
    pub fn cvMatchShapes(
        object1: *const ::std::os::raw::c_void,
        object2: *const ::std::os::raw::c_void,
        method: ::std::os::raw::c_int,
        parameter: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Calculates exact convex hull of 2d point set"]
    #[doc = "@see cv::convexHull"]
    pub fn cvConvexHull2(
        input: *const CvArr,
        hull_storage: *mut ::std::os::raw::c_void,
        orientation: ::std::os::raw::c_int,
        return_points: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Checks whether the contour is convex or not (returns 1 if convex, 0 if not)"]
    #[doc = "@see cv::isContourConvex"]
    pub fn cvCheckContourConvexity(
        contour: *const CvArr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Finds convexity defects for the contour"]
    #[doc = "@see cv::convexityDefects"]
    pub fn cvConvexityDefects(
        contour: *const CvArr,
        convexhull: *const CvArr,
        storage: *mut CvMemStorage,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Fits ellipse into a set of 2d points"]
    #[doc = "@see cv::fitEllipse"]
    pub fn cvFitEllipse2(points: *const CvArr) -> CvBox2D;
}
extern "C" {
    #[doc = " @brief Finds minimum rectangle containing two given rectangles"]
    pub fn cvMaxRect(rect1: *const CvRect, rect2: *const CvRect) -> CvRect;
}
extern "C" {
    #[doc = " @brief Finds coordinates of the box vertices"]
    pub fn cvBoxPoints(box_: CvBox2D, pt: *mut CvPoint2D32f);
}
extern "C" {
    #[doc = " @brief Initializes sequence header for a matrix (column or row vector) of points"]
    #[doc = ""]
    #[doc = "a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)"]
    pub fn cvPointSeqFromMat(
        seq_kind: ::std::os::raw::c_int,
        mat: *const CvArr,
        contour_header: *mut CvContour,
        block: *mut CvSeqBlock,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Checks whether the point is inside polygon, outside, on an edge (at a vertex)."]
    #[doc = ""]
    #[doc = "Returns positive, negative or zero value, correspondingly."]
    #[doc = "Optionally, measures a signed distance between"]
    #[doc = "the point and the nearest polygon edge (measure_dist=1)"]
    #[doc = "@see cv::pointPolygonTest"]
    pub fn cvPointPolygonTest(
        contour: *const CvArr,
        pt: CvPoint2D32f,
        measure_dist: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Creates a histogram."]
    #[doc = ""]
    #[doc = "The function creates a histogram of the specified size and returns a pointer to the created"]
    #[doc = "histogram. If the array ranges is 0, the histogram bin ranges must be specified later via the"]
    #[doc = "function cvSetHistBinRanges. Though cvCalcHist and cvCalcBackProject may process 8-bit images"]
    #[doc = "without setting bin ranges, they assume they are equally spaced in 0 to 255 bins."]
    #[doc = ""]
    #[doc = "@param dims Number of histogram dimensions."]
    #[doc = "@param sizes Array of the histogram dimension sizes."]
    #[doc = "@param type Histogram representation format. CV_HIST_ARRAY means that the histogram data is"]
    #[doc = "represented as a multi-dimensional dense array CvMatND. CV_HIST_SPARSE means that histogram data"]
    #[doc = "is represented as a multi-dimensional sparse array CvSparseMat."]
    #[doc = "@param ranges Array of ranges for the histogram bins. Its meaning depends on the uniform parameter"]
    #[doc = "value. The ranges are used when the histogram is calculated or backprojected to determine which"]
    #[doc = "histogram bin corresponds to which value/tuple of values from the input image(s)."]
    #[doc = "@param uniform Uniformity flag. If not zero, the histogram has evenly spaced bins and for every"]
    #[doc = "\\f$0<=i<cDims\\f$ ranges[i] is an array of two numbers: lower and upper boundaries for the i-th"]
    #[doc = "histogram dimension. The whole range [lower,upper] is then split into dims[i] equal parts to"]
    #[doc = "determine the i-th input tuple value ranges for every histogram bin. And if uniform=0 , then the"]
    #[doc = "i-th element of the ranges array contains dims[i]+1 elements: \\f$\\texttt{lower}_0,"]
    #[doc = "\\texttt{upper}_0, \\texttt{lower}_1, \\texttt{upper}_1 = \\texttt{lower}_2,"]
    #[doc = "..."]
    #[doc = "\\texttt{upper}_{dims[i]-1}\\f$ where \\f$\\texttt{lower}_j\\f$ and \\f$\\texttt{upper}_j\\f$ are lower"]
    #[doc = "and upper boundaries of the i-th input tuple value for the j-th bin, respectively. In either"]
    #[doc = "case, the input values that are beyond the specified range for a histogram bin are not counted"]
    #[doc = "by cvCalcHist and filled with 0 by cvCalcBackProject."]
    pub fn cvCreateHist(
        dims: ::std::os::raw::c_int,
        sizes: *mut ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        ranges: *mut *mut f32,
        uniform: ::std::os::raw::c_int,
    ) -> *mut CvHistogram;
}
extern "C" {
    #[doc = " @brief Sets the bounds of the histogram bins."]
    #[doc = ""]
    #[doc = "This is a standalone function for setting bin ranges in the histogram. For a more detailed"]
    #[doc = "description of the parameters ranges and uniform, see the :ocvCalcHist function that can initialize"]
    #[doc = "the ranges as well. Ranges for the histogram bins must be set before the histogram is calculated or"]
    #[doc = "the backproject of the histogram is calculated."]
    #[doc = ""]
    #[doc = "@param hist Histogram."]
    #[doc = "@param ranges Array of bin ranges arrays. See :ocvCreateHist for details."]
    #[doc = "@param uniform Uniformity flag. See :ocvCreateHist for details."]
    pub fn cvSetHistBinRanges(
        hist: *mut CvHistogram,
        ranges: *mut *mut f32,
        uniform: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Makes a histogram out of an array."]
    #[doc = ""]
    #[doc = "The function initializes the histogram, whose header and bins are allocated by the user."]
    #[doc = "cvReleaseHist does not need to be called afterwards. Only dense histograms can be initialized this"]
    #[doc = "way. The function returns hist."]
    #[doc = ""]
    #[doc = "@param dims Number of the histogram dimensions."]
    #[doc = "@param sizes Array of the histogram dimension sizes."]
    #[doc = "@param hist Histogram header initialized by the function."]
    #[doc = "@param data Array used to store histogram bins."]
    #[doc = "@param ranges Histogram bin ranges. See cvCreateHist for details."]
    #[doc = "@param uniform Uniformity flag. See cvCreateHist for details."]
    pub fn cvMakeHistHeaderForArray(
        dims: ::std::os::raw::c_int,
        sizes: *mut ::std::os::raw::c_int,
        hist: *mut CvHistogram,
        data: *mut f32,
        ranges: *mut *mut f32,
        uniform: ::std::os::raw::c_int,
    ) -> *mut CvHistogram;
}
extern "C" {
    #[doc = " @brief Releases the histogram."]
    #[doc = ""]
    #[doc = "The function releases the histogram (header and the data). The pointer to the histogram is cleared"]
    #[doc = "by the function. If \\*hist pointer is already NULL, the function does nothing."]
    #[doc = ""]
    #[doc = "@param hist Double pointer to the released histogram."]
    pub fn cvReleaseHist(hist: *mut *mut CvHistogram);
}
extern "C" {
    #[doc = " @brief Clears the histogram."]
    #[doc = ""]
    #[doc = "The function sets all of the histogram bins to 0 in case of a dense histogram and removes all"]
    #[doc = "histogram bins in case of a sparse array."]
    #[doc = ""]
    #[doc = "@param hist Histogram."]
    pub fn cvClearHist(hist: *mut CvHistogram);
}
extern "C" {
    #[doc = " @brief Finds the minimum and maximum histogram bins."]
    #[doc = ""]
    #[doc = "The function finds the minimum and maximum histogram bins and their positions. All of output"]
    #[doc = "arguments are optional. Among several extremas with the same value the ones with the minimum index"]
    #[doc = "(in the lexicographical order) are returned. In case of several maximums or minimums, the earliest"]
    #[doc = "in the lexicographical order (extrema locations) is returned."]
    #[doc = ""]
    #[doc = "@param hist Histogram."]
    #[doc = "@param min_value Pointer to the minimum value of the histogram."]
    #[doc = "@param max_value Pointer to the maximum value of the histogram."]
    #[doc = "@param min_idx Pointer to the array of coordinates for the minimum."]
    #[doc = "@param max_idx Pointer to the array of coordinates for the maximum."]
    pub fn cvGetMinMaxHistValue(
        hist: *const CvHistogram,
        min_value: *mut f32,
        max_value: *mut f32,
        min_idx: *mut ::std::os::raw::c_int,
        max_idx: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Normalizes the histogram."]
    #[doc = ""]
    #[doc = "The function normalizes the histogram bins by scaling them so that the sum of the bins becomes equal"]
    #[doc = "to factor."]
    #[doc = ""]
    #[doc = "@param hist Pointer to the histogram."]
    #[doc = "@param factor Normalization factor."]
    pub fn cvNormalizeHist(hist: *mut CvHistogram, factor: f64);
}
extern "C" {
    #[doc = " @brief Thresholds the histogram."]
    #[doc = ""]
    #[doc = "The function clears histogram bins that are below the specified threshold."]
    #[doc = ""]
    #[doc = "@param hist Pointer to the histogram."]
    #[doc = "@param threshold Threshold level."]
    pub fn cvThreshHist(hist: *mut CvHistogram, threshold: f64);
}
extern "C" {
    #[doc = " Compares two histogram"]
    pub fn cvCompareHist(
        hist1: *const CvHistogram,
        hist2: *const CvHistogram,
        method: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Copies a histogram."]
    #[doc = ""]
    #[doc = "The function makes a copy of the histogram. If the second histogram pointer \\*dst is NULL, a new"]
    #[doc = "histogram of the same size as src is created. Otherwise, both histograms must have equal types and"]
    #[doc = "sizes. Then the function copies the bin values of the source histogram to the destination histogram"]
    #[doc = "and sets the same bin value ranges as in src."]
    #[doc = ""]
    #[doc = "@param src Source histogram."]
    #[doc = "@param dst Pointer to the destination histogram."]
    pub fn cvCopyHist(src: *const CvHistogram, dst: *mut *mut CvHistogram);
}
extern "C" {
    #[doc = " @brief Calculates bayesian probabilistic histograms"]
    #[doc = "(each or src and dst is an array of _number_ histograms"]
    pub fn cvCalcBayesianProb(
        src: *mut *mut CvHistogram,
        number: ::std::os::raw::c_int,
        dst: *mut *mut CvHistogram,
    );
}
extern "C" {
    #[doc = " @brief Calculates array histogram"]
    #[doc = "@see cv::calcHist"]
    pub fn cvCalcArrHist(
        arr: *mut *mut CvArr,
        hist: *mut CvHistogram,
        accumulate: ::std::os::raw::c_int,
        mask: *const CvArr,
    );
}
extern "C" {
    #[doc = " @brief Calculates back project"]
    #[doc = "@see cvCalcBackProject, cv::calcBackProject"]
    pub fn cvCalcArrBackProject(
        image: *mut *mut CvArr,
        dst: *mut CvArr,
        hist: *const CvHistogram,
    );
}
extern "C" {
    #[doc = " @brief Locates a template within an image by using a histogram comparison."]
    #[doc = ""]
    #[doc = "The function calculates the back projection by comparing histograms of the source image patches with"]
    #[doc = "the given histogram. The function is similar to matchTemplate, but instead of comparing the raster"]
    #[doc = "patch with all its possible positions within the search window, the function CalcBackProjectPatch"]
    #[doc = "compares histograms. See the algorithm diagram below:"]
    #[doc = ""]
    #[doc = "[image](pics/backprojectpatch.png)"]
    #[doc = ""]
    #[doc = "@param image Source images (though, you may pass CvMat\\*\\* as well)."]
    #[doc = "@param dst Destination image."]
    #[doc = "@param range"]
    #[doc = "@param hist Histogram."]
    #[doc = "@param method Comparison method passed to cvCompareHist (see the function description)."]
    #[doc = "@param factor Normalization factor for histograms that affects the normalization scale of the"]
    #[doc = "destination image. Pass 1 if not sure."]
    #[doc = ""]
    #[doc = "@see cvCalcBackProjectPatch"]
    pub fn cvCalcArrBackProjectPatch(
        image: *mut *mut CvArr,
        dst: *mut CvArr,
        range: CvSize,
        hist: *mut CvHistogram,
        method: ::std::os::raw::c_int,
        factor: f64,
    );
}
extern "C" {
    #[doc = " @brief Divides one histogram by another."]
    #[doc = ""]
    #[doc = "The function calculates the object probability density from two histograms as:"]
    #[doc = ""]
    #[doc = "\\f[\\texttt{disthist} (I)= \\forkthree{0}{if \\(\\texttt{hist1}(I)=0\\)}{\\texttt{scale}}{if \\(\\texttt{hist1}(I) \\ne 0\\) and \\(\\texttt{hist2}(I) > \\texttt{hist1}(I)\\)}{\\frac{\\texttt{hist2}(I) \\cdot \\texttt{scale}}{\\texttt{hist1}(I)}}{if \\(\\texttt{hist1}(I) \\ne 0\\) and \\(\\texttt{hist2}(I) \\le \\texttt{hist1}(I)\\)}\\f]"]
    #[doc = ""]
    #[doc = "@param hist1 First histogram (the divisor)."]
    #[doc = "@param hist2 Second histogram."]
    #[doc = "@param dst_hist Destination histogram."]
    #[doc = "@param scale Scale factor for the destination histogram."]
    pub fn cvCalcProbDensity(
        hist1: *const CvHistogram,
        hist2: *const CvHistogram,
        dst_hist: *mut CvHistogram,
        scale: f64,
    );
}
extern "C" {
    #[doc = " @brief equalizes histogram of 8-bit single-channel image"]
    #[doc = "@see cv::equalizeHist"]
    pub fn cvEqualizeHist(src: *const CvArr, dst: *mut CvArr);
}
extern "C" {
    #[doc = " @brief Applies distance transform to binary image"]
    #[doc = "@see cv::distanceTransform"]
    pub fn cvDistTransform(
        src: *const CvArr,
        dst: *mut CvArr,
        distance_type: ::std::os::raw::c_int,
        mask_size: ::std::os::raw::c_int,
        mask: *const f32,
        labels: *mut CvArr,
        labelType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Applies fixed-level threshold to grayscale image."]
    #[doc = ""]
    #[doc = "This is a basic operation applied before retrieving contours"]
    #[doc = "@see cv::threshold"]
    pub fn cvThreshold(
        src: *const CvArr,
        dst: *mut CvArr,
        threshold: f64,
        max_value: f64,
        threshold_type: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Applies adaptive threshold to grayscale image."]
    #[doc = ""]
    #[doc = "The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and"]
    #[doc = "CV_ADAPTIVE_THRESH_GAUSSIAN_C are:"]
    #[doc = "neighborhood size (3, 5, 7 etc.),"]
    #[doc = "and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)"]
    #[doc = "@see cv::adaptiveThreshold"]
    pub fn cvAdaptiveThreshold(
        src: *const CvArr,
        dst: *mut CvArr,
        max_value: f64,
        adaptive_method: ::std::os::raw::c_int,
        threshold_type: ::std::os::raw::c_int,
        block_size: ::std::os::raw::c_int,
        param1: f64,
    );
}
extern "C" {
    #[doc = " @brief Fills the connected component until the color difference gets large enough"]
    #[doc = "@see cv::floodFill"]
    pub fn cvFloodFill(
        image: *mut CvArr,
        seed_point: CvPoint,
        new_val: CvScalar,
        lo_diff: CvScalar,
        up_diff: CvScalar,
        comp: *mut CvConnectedComp,
        flags: ::std::os::raw::c_int,
        mask: *mut CvArr,
    );
}
extern "C" {
    #[doc = " @brief Runs canny edge detector"]
    #[doc = "@see cv::Canny"]
    pub fn cvCanny(
        image: *const CvArr,
        edges: *mut CvArr,
        threshold1: f64,
        threshold2: f64,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates constraint image for corner detection"]
    #[doc = ""]
    #[doc = "Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy."]
    #[doc = "Applying threshold to the result gives coordinates of corners"]
    #[doc = "@see cv::preCornerDetect"]
    pub fn cvPreCornerDetect(
        image: *const CvArr,
        corners: *mut CvArr,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates eigen values and vectors of 2x2"]
    #[doc = "gradient covariation matrix at every image pixel"]
    #[doc = "@see cv::cornerEigenValsAndVecs"]
    pub fn cvCornerEigenValsAndVecs(
        image: *const CvArr,
        eigenvv: *mut CvArr,
        block_size: ::std::os::raw::c_int,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Calculates minimal eigenvalue for 2x2 gradient covariation matrix at"]
    #[doc = "every image pixel"]
    #[doc = "@see cv::cornerMinEigenVal"]
    pub fn cvCornerMinEigenVal(
        image: *const CvArr,
        eigenval: *mut CvArr,
        block_size: ::std::os::raw::c_int,
        aperture_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Harris corner detector:"]
    #[doc = ""]
    #[doc = "Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel"]
    #[doc = "@see cv::cornerHarris"]
    pub fn cvCornerHarris(
        image: *const CvArr,
        harris_response: *mut CvArr,
        block_size: ::std::os::raw::c_int,
        aperture_size: ::std::os::raw::c_int,
        k: f64,
    );
}
extern "C" {
    #[doc = " @brief Adjust corner position using some sort of gradient search"]
    #[doc = "@see cv::cornerSubPix"]
    pub fn cvFindCornerSubPix(
        image: *const CvArr,
        corners: *mut CvPoint2D32f,
        count: ::std::os::raw::c_int,
        win: CvSize,
        zero_zone: CvSize,
        criteria: CvTermCriteria,
    );
}
extern "C" {
    #[doc = " @brief Finds a sparse set of points within the selected region"]
    #[doc = "that seem to be easy to track"]
    #[doc = "@see cv::goodFeaturesToTrack"]
    pub fn cvGoodFeaturesToTrack(
        image: *const CvArr,
        eig_image: *mut CvArr,
        temp_image: *mut CvArr,
        corners: *mut CvPoint2D32f,
        corner_count: *mut ::std::os::raw::c_int,
        quality_level: f64,
        min_distance: f64,
        mask: *const CvArr,
        block_size: ::std::os::raw::c_int,
        use_harris: ::std::os::raw::c_int,
        k: f64,
    );
}
extern "C" {
    #[doc = " @brief Finds lines on binary image using one of several methods."]
    #[doc = ""]
    #[doc = "line_storage is either memory storage or 1 x _max number of lines_ CvMat, its"]
    #[doc = "number of columns is changed by the function."]
    #[doc = "method is one of CV_HOUGH_*;"]
    #[doc = "rho, theta and threshold are used for each of those methods;"]
    #[doc = "param1 ~ line length, param2 ~ line gap - for probabilistic,"]
    #[doc = "param1 ~ srn, param2 ~ stn - for multi-scale"]
    #[doc = "@see cv::HoughLines"]
    pub fn cvHoughLines2(
        image: *mut CvArr,
        line_storage: *mut ::std::os::raw::c_void,
        method: ::std::os::raw::c_int,
        rho: f64,
        theta: f64,
        threshold: ::std::os::raw::c_int,
        param1: f64,
        param2: f64,
        min_theta: f64,
        max_theta: f64,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Finds circles in the image"]
    #[doc = "@see cv::HoughCircles"]
    pub fn cvHoughCircles(
        image: *mut CvArr,
        circle_storage: *mut ::std::os::raw::c_void,
        method: ::std::os::raw::c_int,
        dp: f64,
        min_dist: f64,
        param1: f64,
        param2: f64,
        min_radius: ::std::os::raw::c_int,
        max_radius: ::std::os::raw::c_int,
    ) -> *mut CvSeq;
}
extern "C" {
    #[doc = " @brief Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)"]
    #[doc = "@see cv::fitLine"]
    pub fn cvFitLine(
        points: *const CvArr,
        dist_type: ::std::os::raw::c_int,
        param: f64,
        reps: f64,
        aeps: f64,
        line: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Draws 4-connected, 8-connected or antialiased line segment connecting two points"]
    #[doc = "@see cv::line"]
    pub fn cvLine(
        img: *mut CvArr,
        pt1: CvPoint,
        pt2: CvPoint,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2)"]
    #[doc = ""]
    #[doc = "if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn"]
    #[doc = "@see cv::rectangle"]
    pub fn cvRectangle(
        img: *mut CvArr,
        pt1: CvPoint,
        pt2: CvPoint,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle specified by a CvRect structure"]
    #[doc = "@see cv::rectangle"]
    pub fn cvRectangleR(
        img: *mut CvArr,
        r: CvRect,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a circle with specified center and radius."]
    #[doc = ""]
    #[doc = "Thickness works in the same way as with cvRectangle"]
    #[doc = "@see cv::circle"]
    pub fn cvCircle(
        img: *mut CvArr,
        center: CvPoint,
        radius: ::std::os::raw::c_int,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector"]
    #[doc = ""]
    #[doc = "depending on _thickness_, _start_angle_ and _end_angle_ parameters. The resultant figure"]
    #[doc = "is rotated by _angle_. All the angles are in degrees"]
    #[doc = "@see cv::ellipse"]
    pub fn cvEllipse(
        img: *mut CvArr,
        center: CvPoint,
        axes: CvSize,
        angle: f64,
        start_angle: f64,
        end_angle: f64,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Fills convex or monotonous polygon."]
    #[doc = "@see cv::fillConvexPoly"]
    pub fn cvFillConvexPoly(
        img: *mut CvArr,
        pts: *const CvPoint,
        npts: ::std::os::raw::c_int,
        color: CvScalar,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Fills an area bounded by one or more arbitrary polygons"]
    #[doc = "@see cv::fillPoly"]
    pub fn cvFillPoly(
        img: *mut CvArr,
        pts: *mut *mut CvPoint,
        npts: *const ::std::os::raw::c_int,
        contours: ::std::os::raw::c_int,
        color: CvScalar,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws one or more polygonal curves"]
    #[doc = "@see cv::polylines"]
    pub fn cvPolyLine(
        img: *mut CvArr,
        pts: *mut *mut CvPoint,
        npts: *const ::std::os::raw::c_int,
        contours: ::std::os::raw::c_int,
        is_closed: ::std::os::raw::c_int,
        color: CvScalar,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        shift: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Clips the line segment connecting *pt1 and *pt2"]
    #[doc = "by the rectangular window"]
    #[doc = ""]
    #[doc = "(0<=x<img_size.width, 0<=y<img_size.height)."]
    #[doc = "@see cv::clipLine"]
    pub fn cvClipLine(
        img_size: CvSize,
        pt1: *mut CvPoint,
        pt2: *mut CvPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initializes line iterator."]
    #[doc = ""]
    #[doc = "Initially, line_iterator->ptr will point to pt1 (or pt2, see left_to_right description) location in"]
    #[doc = "the image. Returns the number of pixels on the line between the ending points."]
    #[doc = "@see cv::LineIterator"]
    pub fn cvInitLineIterator(
        image: *const CvArr,
        pt1: CvPoint,
        pt2: CvPoint,
        line_iterator: *mut CvLineIterator,
        connectivity: ::std::os::raw::c_int,
        left_to_right: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Font structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CvFont {
    pub nameFont: *const ::std::os::raw::c_char,
    pub color: CvScalar,
    pub font_face: ::std::os::raw::c_int,
    #[doc = "!< font data and metrics"]
    pub ascii: *const ::std::os::raw::c_int,
    pub greek: *const ::std::os::raw::c_int,
    pub cyrillic: *const ::std::os::raw::c_int,
    pub hscale: f32,
    pub vscale: f32,
    #[doc = "!< slope coefficient: 0 - normal, >0 - italic"]
    pub shear: f32,
    #[doc = "!< Qt: weight               /** letters thickness */"]
    pub thickness: ::std::os::raw::c_int,
    #[doc = "!< horizontal interval between letters"]
    pub dx: f32,
    #[doc = "!< Qt: PointSize"]
    pub line_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CvFont() {
    assert_eq!(
        ::std::mem::size_of::<CvFont>(),
        96usize,
        concat!("Size of: ", stringify!(CvFont))
    );
    assert_eq!(
        ::std::mem::align_of::<CvFont>(),
        8usize,
        concat!("Alignment of ", stringify!(CvFont))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).nameFont as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(nameFont)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).font_face as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(font_face)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).ascii as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(ascii)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).greek as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(greek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).cyrillic as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(cyrillic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).hscale as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(hscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).vscale as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(vscale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).shear as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(shear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).thickness as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(thickness)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CvFont>())).dx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CvFont>())).line_type as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(CvFont),
            "::",
            stringify!(line_type)
        )
    );
}
extern "C" {
    #[doc = " @brief Initializes font structure (OpenCV 1.x API)."]
    #[doc = ""]
    #[doc = "The function initializes the font structure that can be passed to text rendering functions."]
    #[doc = ""]
    #[doc = "@param font Pointer to the font structure initialized by the function"]
    #[doc = "@param font_face Font name identifier. See cv::HersheyFonts and corresponding old CV_* identifiers."]
    #[doc = "@param hscale Horizontal scale. If equal to 1.0f , the characters have the original width"]
    #[doc = "depending on the font type. If equal to 0.5f , the characters are of half the original width."]
    #[doc = "@param vscale Vertical scale. If equal to 1.0f , the characters have the original height depending"]
    #[doc = "on the font type. If equal to 0.5f , the characters are of half the original height."]
    #[doc = "@param shear Approximate tangent of the character slope relative to the vertical line. A zero"]
    #[doc = "value means a non-italic font, 1.0f means about a 45 degree slope, etc."]
    #[doc = "@param thickness Thickness of the text strokes"]
    #[doc = "@param line_type Type of the strokes, see line description"]
    #[doc = ""]
    #[doc = "@sa cvPutText"]
    pub fn cvInitFont(
        font: *mut CvFont,
        font_face: ::std::os::raw::c_int,
        hscale: f64,
        vscale: f64,
        shear: f64,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Renders text stroke with specified font and color at specified location."]
    #[doc = "CvFont should be initialized with cvInitFont"]
    #[doc = "@see cvInitFont, cvGetTextSize, cvFont, cv::putText"]
    pub fn cvPutText(
        img: *mut CvArr,
        text: *const ::std::os::raw::c_char,
        org: CvPoint,
        font: *const CvFont,
        color: CvScalar,
    );
}
extern "C" {
    #[doc = " @brief Calculates bounding box of text stroke (useful for alignment)"]
    #[doc = "@see cv::getTextSize"]
    pub fn cvGetTextSize(
        text_string: *const ::std::os::raw::c_char,
        font: *const CvFont,
        text_size: *mut CvSize,
        baseline: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Unpacks color value"]
    #[doc = ""]
    #[doc = "if arrtype is CV_8UC?, _color_ is treated as packed color value, otherwise the first channels"]
    #[doc = "(depending on arrtype) of destination scalar are set to the same value = _color_"]
    pub fn cvColorToScalar(
        packed_color: f64,
        arrtype: ::std::os::raw::c_int,
    ) -> CvScalar;
}
extern "C" {
    #[doc = " @brief Returns the polygon points which make up the given ellipse."]
    #[doc = ""]
    #[doc = "The ellipse is define by the box of size \'axes\' rotated \'angle\' around the \'center\'. A partial"]
    #[doc = "sweep of the ellipse arc can be done by spcifying arc_start and arc_end to be something other than"]
    #[doc = "0 and 360, respectively. The input array \'pts\' must be large enough to hold the result. The total"]
    #[doc = "number of points stored into \'pts\' is returned by this function."]
    #[doc = "@see cv::ellipse2Poly"]
    pub fn cvEllipse2Poly(
        center: CvPoint,
        axes: CvSize,
        angle: ::std::os::raw::c_int,
        arc_start: ::std::os::raw::c_int,
        arc_end: ::std::os::raw::c_int,
        pts: *mut CvPoint,
        delta: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Draws contour outlines or filled interiors on the image"]
    #[doc = "@see cv::drawContours"]
    pub fn cvDrawContours(
        img: *mut CvArr,
        contour: *mut CvSeq,
        external_color: CvScalar,
        hole_color: CvScalar,
        max_level: ::std::os::raw::c_int,
        thickness: ::std::os::raw::c_int,
        line_type: ::std::os::raw::c_int,
        offset: CvPoint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IplTileInfo {
    pub _address: u8,
}
